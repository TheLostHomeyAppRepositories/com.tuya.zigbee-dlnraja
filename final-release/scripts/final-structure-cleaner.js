// MEGA ULTIMATE ENHANCED - 2025-08-07T16:33:44.676Z
// Script amélioré avec liens corrigés et fonctionnalités étendues

// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); class FinalStructureCleaner { constructor() { this.root = path.resolve(__dirname, '../drivers'); this.tuyaRoot = path.join(this.root, 'tuya'); this.zigbeeRoot = path.join(this.root, 'zigbee'); // Structure cible selon le MEGA-PROMPT this.expectedTuyaDirs = ['lights', 'switches', 'plugs', 'sensors', 'thermostats']; this.expectedZigbeeDirs = ['onoff', 'dimmers', 'sensors']; this.moveHistory = []; this.deletedDirs = []; this.fusedDrivers = []; } async cleanStructure() { console.log('🧹 NETTOYAGE FINAL DE LA STRUCTURE DES DRIVERS'); console.log('=' .repeat(60)); // 1. Nettoyer drivers/tuya/ await this.cleanTuyaStructure(); // 2. Nettoyer drivers/zigbee/ await this.cleanZigbeeStructure(); // 3. Fusionner les drivers similaires await this.mergeSimilarDrivers(); // 4. Générer les rapports await this.generateReports(); console.log('\n✅ NETTOYAGE FINAL TERMINÉ !'); } async cleanTuyaStructure() { console.log('\n📁 Nettoyage de drivers/tuya/...'); const tuyaDirs = fs.readdirSync(this.tuyaRoot); for (const dir of tuyaDirs) { const fullPath = path.join(this.tuyaRoot, dir); if (!fs.lstatSync(fullPath).isDirectory()) continue; if (!this.expectedTuyaDirs.includes(dir)) { console.log(`❌ Dossier non autorisé détecté: drivers/tuya/${dir}`); // Déplacer vers la catégorie appropriée ou supprimer if (['unknown', 'assets', 'historical', 'smart-life', 'controls'].includes(dir)) { console.log(`🗑️ Suppression du dossier obsolète: ${dir}`); this.deleteDirectory(fullPath); this.deletedDirs.push(`drivers/tuya/${dir}`); } else { // Essayer de reclasser await this.reclassifyDriver(fullPath, 'tuya'); } } } } async cleanZigbeeStructure() { console.log('\n📁 Nettoyage de drivers/zigbee/...'); const zigbeeDirs = fs.readdirSync(this.zigbeeRoot); for (const dir of zigbeeDirs) { const fullPath = path.join(this.zigbeeRoot, dir); if (!fs.lstatSync(fullPath).isDirectory()) continue; if (!this.expectedZigbeeDirs.includes(dir)) { console.log(`❌ Dossier non autorisé détecté: drivers/zigbee/${dir}`); // Déplacer vers la catégorie appropriée ou supprimer if (['unknown', 'assets', 'historical', 'smart-life', 'controls'].includes(dir)) { console.log(`🗑️ Suppression du dossier obsolète: ${dir}`); this.deleteDirectory(fullPath); this.deletedDirs.push(`drivers/zigbee/${dir}`); } else { // Essayer de reclasser await this.reclassifyDriver(fullPath, 'zigbee'); } } } } async reclassifyDriver(driverPath, type) { try { const driverName = path.basename(driverPath); const deviceFile = path.join(driverPath, 'device.js'); if (!fs.existsSync(deviceFile)) { console.log(`⚠️ Pas de device.js trouvé dans ${driverName}`); return; } const content = fs.readFileSync(deviceFile, 'utf8'); const category = this.detectDriverCategory(content, type); if (category) { const targetDir = path.join(this.root, type, category); const targetPath = path.join(targetDir, driverName); if (!fs.existsSync(targetDir)) { fs.mkdirSync(targetDir, { recursive: true }); } if (fs.existsSync(targetPath)) { console.log(`🔄 Fusion avec driver existant: ${driverName}`); await this.mergeDrivers(driverPath, targetPath); } else { console.log(`📦 Déplacement: ${driverName} → ${type}/${category}/`); fs.renameSync(driverPath, targetPath); this.moveHistory.push({ from: `${type}/${path.basename(driverPath)}`, to: `${type}/${category}/${driverName}`, timestamp: new Date().toISOString() }); } } } catch (error) { console.log(`❌ Erreur lors du reclassement de ${path.basename(driverPath)}: ${error.message}`); } } detectDriverCategory(content, type) { const lowerContent = content.toLowerCase(); if (type === 'tuya') { if (lowerContent.includes('light') || lowerContent.includes('bulb') || lowerContent.includes('lamp')) return 'lights'; if (lowerContent.includes('switch') || lowerContent.includes('button')) return 'switches'; if (lowerContent.includes('plug') || lowerContent.includes('socket')) return 'plugs'; if (lowerContent.includes('sensor') || lowerContent.includes('motion') || lowerContent.includes('temperature')) return 'sensors'; if (lowerContent.includes('thermostat') || lowerContent.includes('climate')) return 'thermostats'; } else if (type === 'zigbee') { if (lowerContent.includes('onoff') || lowerContent.includes('switch')) return 'onoff'; if (lowerContent.includes('dimmer') || lowerContent.includes('dim')) return 'dimmers'; if (lowerContent.includes('sensor') || lowerContent.includes('motion') || lowerContent.includes('temperature')) return 'sensors'; } return null; } async mergeDrivers(sourcePath, targetPath) { try { // Fusion simple - copier les fichiers manquants const sourceFiles = fs.readdirSync(sourcePath); const targetFiles = fs.readdirSync(targetPath); for (const file of sourceFiles) { const sourceFile = path.join(sourcePath, file); const targetFile = path.join(targetPath, file); if (!targetFiles.includes(file)) { fs.copyFileSync(sourceFile, targetFile); console.log(` 📄 Copié: ${file}`); } } // Supprimer le dossier source this.deleteDirectory(sourcePath); this.fusedDrivers.push({ source: path.basename(sourcePath), target: path.basename(targetPath), timestamp: new Date().toISOString() }); } catch (error) { console.log(`❌ Erreur lors de la fusion: ${error.message}`); } } deleteDirectory(dirPath) { try { if (fs.existsSync(dirPath)) { fs.rmSync(dirPath, { recursive: true, force: true }); } } catch (error) { console.log(`⚠️ Erreur lors de la suppression de ${dirPath}: ${error.message}`); } } async mergeSimilarDrivers() { console.log('\n🔄 Fusion des drivers similaires...'); // Fusion dans chaque catégorie for (const type of ['tuya', 'zigbee']) { const typeRoot = path.join(this.root, type); if (!fs.existsSync(typeRoot)) continue; const categories = fs.readdirSync(typeRoot); for (const category of categories) { const categoryPath = path.join(typeRoot, category); if (!fs.lstatSync(categoryPath).isDirectory()) continue; const drivers = fs.readdirSync(categoryPath); const similarGroups = this.findSimilarDrivers(drivers, categoryPath); for (const group of similarGroups) { if (group.length > 1) { await this.mergeDriverGroup(group, categoryPath); } } } } } findSimilarDrivers(drivers, categoryPath) { const groups = []; const processed = new Set(); for (const driver of drivers) { if (processed.has(driver)) continue; const group = [driver]; processed.add(driver); // Chercher des drivers similaires for (const otherDriver of drivers) { if (processed.has(otherDriver)) continue; if (this.areDriversSimilar(driver, otherDriver, categoryPath)) { group.push(otherDriver); processed.add(otherDriver); } } groups.push(group); } return groups; } areDriversSimilar(driver1, driver2, categoryPath) { try { const device1Path = path.join(categoryPath, driver1, 'device.js'); const device2Path = path.join(categoryPath, driver2, 'device.js'); if (!fs.existsSync(device1Path) || !fs.existsSync(device2Path)) { return false; } const content1 = fs.readFileSync(device1Path, 'utf8'); const content2 = fs.readFileSync(device2Path, 'utf8'); // Comparaison simple basée sur les mots-clés const keywords1 = this.extractKeywords(content1); const keywords2 = this.extractKeywords(content2); const similarity = this.calculateSimilarity(keywords1, keywords2); return similarity > 0.7; // 70% de similarité } catch (error) { return false; } } extractKeywords(content) { const keywords = content.toLowerCase() .replace(/[^\w\s]/g, ' ') .split(/\s+/) .filter(word => word.length > 3) .filter(word => !['this', 'that', 'with', 'from', 'have', 'will', 'been', 'they', 'were', 'said', 'each', 'which', 'their', 'time', 'would', 'there', 'could', 'other', 'than', 'first', 'water', 'after', 'where', 'called', 'about', 'again', 'under', 'never', 'while', 'place', 'years', 'found', 'still', 'large', 'every', 'those', 'between', 'another', 'through', 'during', 'before', 'should', 'world', 'above', 'sometimes', 'something', 'around', 'always', 'though', 'without', 'nothing', 'someone', 'everything', 'anything', 'everyone', 'someone', 'anyone', 'everybody', 'somebody', 'anybody', 'nobody'].includes(word)); return [...new Set(keywords)]; } calculateSimilarity(keywords1, keywords2) { const set1 = new Set(keywords1); const set2 = new Set(keywords2); const intersection = new Set([...set1].filter(x => set2.has(x))); const union = new Set([...set1, ...set2]); return intersection.size / union.size; } async mergeDriverGroup(group, categoryPath) { if (group.length <= 1) return; const primaryDriver = group[0]; const primaryPath = path.join(categoryPath, primaryDriver); console.log(`🔄 Fusion du groupe: ${group.join(', ')} → ${primaryDriver}`); for (let i = 1; i < group.length; i++) { const secondaryDriver = group[i]; const secondaryPath = path.join(categoryPath, secondaryDriver); try { await this.mergeDrivers(secondaryPath, primaryPath); } catch (error) { console.log(`❌ Erreur lors de la fusion de ${secondaryDriver}: ${error.message}`); } } } async generateReports() { console.log('\n📊 Génération des rapports...'); // Mettre à jour move-history.log const moveHistoryLog = path.join(__dirname, 'move-history.log'); const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19); for (const move of this.moveHistory) { const logEntry = `[${timestamp}] Moved 'drivers/${move.from}' → 'drivers/${move.to}'\n`; fs.appendFileSync(moveHistoryLog, logEntry); } // Mettre à jour drivers-index.json await this.updateDriversIndex(); // Générer rapport final await this.generateFinalReport(); } async updateDriversIndex() { const driversIndex = { lastUpdated: new Date().toISOString(), totalDrivers: 0, drivers: [] }; for (const type of ['tuya', 'zigbee']) { const typeRoot = path.join(this.root, type); if (!fs.existsSync(typeRoot)) continue; const categories = fs.readdirSync(typeRoot); for (const category of categories) { const categoryPath = path.join(typeRoot, category); if (!fs.lstatSync(categoryPath).isDirectory()) continue; const drivers = fs.readdirSync(categoryPath); for (const driver of drivers) { const driverPath = path.join(categoryPath, driver); if (!fs.lstatSync(driverPath).isDirectory()) continue; const driverInfo = await this.extractDriverInfo(driverPath, type, category); if (driverInfo) { driversIndex.drivers.push(driverInfo); driversIndex.totalDrivers++; } } } } const indexPath = path.join(__dirname, '../ref/drivers-index.json'); fs.writeFileSync(indexPath, JSON.stringify(driversIndex, null, 2)); } async extractDriverInfo(driverPath, type, category) { try { const deviceFile = path.join(driverPath, 'device.js'); const composeFile = path.join(driverPath, 'driver.compose.json'); if (!fs.existsSync(deviceFile)) return null; const content = fs.readFileSync(deviceFile, 'utf8'); // Extraire les informations de base const driverId = path.basename(driverPath); const manufacturer = this.extractManufacturer(content); const status = this.determineStatus(driverPath); return { driver_id: driverId, path: `${type}/${category}/${driverId}`, class: category, manufacturer: manufacturer, status: status, type: type }; } catch (error) { return null; } } extractManufacturer(content) { const manufacturerMatch = content.match(/manufacturerName\s*[:=]\s*['"`]([^'"`]+)['"`]/i); return manufacturerMatch ? manufacturerMatch[1] : 'Unknown'; } determineStatus(driverPath) { const deviceFile = path.join(driverPath, 'device.js'); const composeFile = path.join(driverPath, 'driver.compose.json'); if (!fs.existsSync(deviceFile)) return 'incomplet'; if (!fs.existsSync(composeFile)) return 'à valider'; try { const composeContent = fs.readFileSync(composeFile, 'utf8'); const compose = JSON.parse(composeContent); if (compose.metadata && compose.metadata.missingCapabilities) { return 'à valider'; } return 'validé'; } catch (error) { return 'à valider'; } } async generateFinalReport() { const report = { timestamp: new Date().toISOString(), summary: { deletedDirectories: this.deletedDirs.length, movedDrivers: this.moveHistory.length, fusedDrivers: this.fusedDrivers.length }, deletedDirectories: this.deletedDirs, movedDrivers: this.moveHistory, fusedDrivers: this.fusedDrivers }; const reportPath = path.join(__dirname, '../FINAL-STRUCTURE-CLEANER-REPORT.md'); const reportContent = `# 🧹 RAPPORT FINAL - NETTOYAGE DE STRUCTURE ## 📊 Résumé - **Dossiers supprimés**: ${report.summary.deletedDirectories} - **Drivers déplacés**: ${report.summary.movedDrivers} - **Drivers fusionnés**: ${report.summary.fusedDrivers} ## 🗑️ Dossiers supprimés ${report.deletedDirectories.map(dir => `- \`${dir}\``).join('\n')} ## 📦 Drivers déplacés ${report.movedDrivers.map(move => `- \`${move.from}\` → \`${move.to}\``).join('\n')} ## 🔄 Drivers fusionnés ${report.fusedDrivers.map(fusion => `- \`${fusion.source}\` → \`${fusion.target}\``).join('\n')} --- *Généré le ${new Date().toLocaleString('fr-FR')}* `; fs.writeFileSync(reportPath, reportContent); console.log(`📄 Rapport généré: ${reportPath}`); } } // Exécution async function main() { const cleaner = new FinalStructureCleaner(); await cleaner.cleanStructure(); } if (require.main === module) { main().catch(console.error); } module.exports = FinalStructureCleaner; 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});