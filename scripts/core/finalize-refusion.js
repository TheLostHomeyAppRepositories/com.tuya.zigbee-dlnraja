#!/usr/bin/env node

/**
 * üéØ FINALIZE REFUSION
 * Version: 1.0.0
 * Date: 2025-08-05
 * 
 * Finalisation de la refusion avec correction de la cat√©gorisation
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class FinalizeRefusion {
    constructor() {
        this.startTime = Date.now();
        this.results = {
            driversRecategorized: 0,
            foldersCleaned: 0,
            megaUpdated: 0,
            errors: []
        };
        
        console.log('üéØ FINALIZE REFUSION - D√âMARRAGE');
        console.log('üìÖ Date:', new Date().toISOString());
        console.log('üéØ Mode: YOLO FINALIZATION');
        console.log('');
    }

    async execute() {
        try {
            await this.recategorizeDrivers();
            await this.cleanupEmptyFolders();
            await this.updateMegaStructure();
            await this.commitFinalization();
            
            this.generateReport();
        } catch (error) {
            console.error('‚ùå Erreur finalisation:', error.message);
            this.results.errors.push(error.message);
        }
    }

    async recategorizeDrivers() {
        console.log('üîÑ RECAT√âGORISATION DES DRIVERS...');
        
        try {
            const lightsPath = 'drivers/tuya/lights';
            if (!fs.existsSync(lightsPath)) {
                console.log('‚ùå Dossier lights non trouv√©');
                return;
            }

            const items = fs.readdirSync(lightsPath);
            
            for (const item of items) {
                const itemPath = path.join(lightsPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    const category = this.determineCategory(item);
                    if (category && category !== 'lights') {
                        await this.moveDriverToCategory(item, itemPath, category);
                    }
                }
            }
            
            console.log(`‚úÖ ${this.results.driversRecategorized} drivers recat√©goris√©s`);

        } catch (error) {
            console.error('‚ùå Erreur recat√©gorisation:', error.message);
            this.results.errors.push(`Recategorization: ${error.message}`);
        }
    }

    determineCategory(driverName) {
        const name = driverName.toLowerCase();
        
        // Logique de cat√©gorisation am√©lior√©e
        if (name.includes('switch') || name.includes('remote') || name.includes('ts0001') || name.includes('ts0044')) {
            return 'switches';
        } else if (name.includes('plug') || name.includes('outlet') || name.includes('ts011f')) {
            return 'plugs';
        } else if (name.includes('sensor') || name.includes('motion') || name.includes('temperature') || name.includes('humidity') || name.includes('soil') || name.includes('water') || name.includes('smart-knob')) {
            return 'sensors';
        } else if (name.includes('cover') || name.includes('curtain') || name.includes('blind') || name.includes('shutter')) {
            return 'covers';
        } else if (name.includes('lock') || name.includes('keypad')) {
            return 'locks';
        } else if (name.includes('thermostat') || name.includes('floor')) {
            return 'thermostats';
        } else if (name.includes('light') || name.includes('bulb') || name.includes('rgb') || name.includes('dimmer') || name.includes('strip')) {
            return 'lights';
        }
        
        // Cat√©goriser les drivers sp√©ciaux
        if (name.includes('report') || name.includes('analysis') || name.includes('matrix') || name.includes('driver') || name.includes('device') || name.includes('complete') || name.includes('comprehensive') || name.includes('historical') || name.includes('verify') || name.includes('ultimate') || name.includes('smart-enrich') || name.includes('test-new') || name.includes('quick') || name.includes('massive') || name.includes('fix') || name.includes('generate') || name.includes('icon') || name.includes('README') || name.includes('tuya-driver') || name.includes('total')) {
            return 'lights'; // Garder dans lights car ce sont des utilitaires
        }
        
        return 'lights'; // Par d√©faut
    }

    async moveDriverToCategory(driverName, sourcePath, targetCategory) {
        try {
            const targetPath = `drivers/tuya/${targetCategory}/${driverName}`;
            
            // Cr√©er le dossier de destination
            fs.mkdirSync(path.dirname(targetPath), { recursive: true });
            
            // D√©placer le driver
            this.moveFolderRecursively(sourcePath, targetPath);
            
            console.log(`‚úÖ Driver d√©plac√©: ${driverName} ‚Üí ${targetCategory}`);
            this.results.driversRecategorized++;
            
        } catch (error) {
            console.error(`‚ùå Erreur d√©placement ${driverName}:`, error.message);
        }
    }

    moveFolderRecursively(sourcePath, targetPath) {
        if (fs.existsSync(sourcePath)) {
            // Cr√©er le dossier de destination
            fs.mkdirSync(targetPath, { recursive: true });
            
            const items = fs.readdirSync(sourcePath);
            
            for (const item of items) {
                const sourceItem = path.join(sourcePath, item);
                const targetItem = path.join(targetPath, item);
                
                if (fs.statSync(sourceItem).isDirectory()) {
                    this.moveFolderRecursively(sourceItem, targetItem);
                } else {
                    fs.copyFileSync(sourceItem, targetItem);
                }
            }
            
            // Supprimer le dossier source
            this.removeFolderRecursively(sourcePath);
        }
    }

    removeFolderRecursively(folderPath) {
        if (fs.existsSync(folderPath)) {
            const items = fs.readdirSync(folderPath);
            
            for (const item of items) {
                const itemPath = path.join(folderPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    this.removeFolderRecursively(itemPath);
                } else {
                    fs.unlinkSync(itemPath);
                }
            }
            
            fs.rmdirSync(folderPath);
        }
    }

    async cleanupEmptyFolders() {
        console.log('üßπ NETTOYAGE DES DOSSIERS VIDES...');
        
        try {
            const categories = ['lights', 'switches', 'plugs', 'sensors', 'covers', 'locks', 'thermostats'];
            
            for (const category of categories) {
                const categoryPath = `drivers/tuya/${category}`;
                if (fs.existsSync(categoryPath)) {
                    const items = fs.readdirSync(categoryPath);
                    
                    // Supprimer les dossiers vides ou les dossiers de rapports
                    for (const item of items) {
                        const itemPath = path.join(categoryPath, item);
                        const itemStat = fs.statSync(itemPath);
                        
                        if (itemStat.isDirectory()) {
                            const subItems = fs.readdirSync(itemPath);
                            if (subItems.length === 0 || this.isReportFolder(item)) {
                                this.removeFolderRecursively(itemPath);
                                console.log(`üóëÔ∏è  Dossier supprim√©: ${itemPath}`);
                                this.results.foldersCleaned++;
                            }
                        }
                    }
                }
            }
            
            console.log(`‚úÖ ${this.results.foldersCleaned} dossiers nettoy√©s`);

        } catch (error) {
            console.error('‚ùå Erreur nettoyage:', error.message);
            this.results.errors.push(`Cleanup: ${error.message}`);
        }
    }

    isReportFolder(folderName) {
        const name = folderName.toLowerCase();
        return name.includes('report') || name.includes('analysis') || name.includes('matrix') || name.includes('driver') || name.includes('device') || name.includes('complete') || name.includes('comprehensive') || name.includes('historical') || name.includes('verify') || name.includes('ultimate') || name.includes('smart-enrich') || name.includes('test-new') || name.includes('quick') || name.includes('massive') || name.includes('fix') || name.includes('generate') || name.includes('icon') || name.includes('README') || name.includes('tuya-driver') || name.includes('total');
    }

    async updateMegaStructure() {
        console.log('üîÑ MISE √Ä JOUR FINALE DE LA STRUCTURE MEGA...');
        
        try {
            // Cr√©er le dossier mega
            const megaPath = 'mega';
            fs.mkdirSync(megaPath, { recursive: true });
            
            // Compter les drivers par cat√©gorie
            const stats = this.countDriversByCategory();
            
            // Cr√©er la structure mega finale
            const megaStructure = {
                drivers: stats.total,
                categories: stats.categories,
                finalization: {
                    driversRecategorized: this.results.driversRecategorized,
                    foldersCleaned: this.results.foldersCleaned,
                    timestamp: new Date().toISOString()
                }
            };
            
            // Sauvegarder la structure mega
            fs.writeFileSync(path.join(megaPath, 'final-structure.json'), JSON.stringify(megaStructure, null, 2));
            
            // Cr√©er un rapport final
            const report = this.generateFinalReport(megaStructure);
            fs.writeFileSync(path.join(megaPath, 'finalization-report.md'), report);
            
            this.results.megaUpdated = 1;
            console.log('‚úÖ Structure mega finale mise √† jour');

        } catch (error) {
            console.error('‚ùå Erreur mise √† jour mega finale:', error.message);
            this.results.errors.push(`Mega final update: ${error.message}`);
        }
    }

    countDriversByCategory() {
        const categories = ['lights', 'switches', 'plugs', 'sensors', 'covers', 'locks', 'thermostats'];
        const stats = {
            total: 0,
            categories: {}
        };
        
        for (const category of categories) {
            const categoryPath = `drivers/tuya/${category}`;
            if (fs.existsSync(categoryPath)) {
                const items = fs.readdirSync(categoryPath);
                const validDrivers = items.filter(item => {
                    const itemPath = path.join(categoryPath, item);
                    return fs.statSync(itemPath).isDirectory() && !this.isReportFolder(item);
                });
                
                stats.categories[category] = validDrivers.length;
                stats.total += validDrivers.length;
            } else {
                stats.categories[category] = 0;
            }
        }
        
        return stats;
    }

    generateFinalReport(structure) {
        return `# üéØ FINALIZATION REPORT

## üìä Statistiques Finales
- **Total drivers**: ${structure.drivers}
- **Drivers recat√©goris√©s**: ${structure.finalization.driversRecategorized}
- **Dossiers nettoy√©s**: ${structure.finalization.foldersCleaned}

## üìÅ Structure Finale par Cat√©gorie

### Tuya Drivers
${Object.entries(structure.categories).map(([cat, count]) => `- **${cat}**: ${count} drivers`).join('\n')}

## üéØ R√©sultat Final
Refusion compl√®te et finalis√©e avec ${structure.drivers} drivers organis√©s et optimis√©s.
`;
    }

    async commitFinalization() {
        console.log('üíæ COMMIT DE LA FINALISATION...');
        
        try {
            execSync('git add .', { stdio: 'pipe' });
            execSync('git commit -m "üéØ FINALIZE REFUSION [EN/FR/NL/TA] - Version 1.0.0 - Recat√©gorisation drivers + Nettoyage dossiers vides + Structure finale optimis√©e + Mise √† jour mega + Projet pr√™t pour validation"', { stdio: 'pipe' });
            execSync('git push origin master', { stdio: 'pipe' });
            console.log('‚úÖ Finalisation commit√©e et pouss√©e');
        } catch (error) {
            console.error('‚ùå Erreur commit:', error.message);
        }
    }

    generateReport() {
        const duration = Date.now() - this.startTime;
        
        console.log('');
        console.log('üìä RAPPORT FINALIZE REFUSION');
        console.log('==============================');
        console.log(`‚è±Ô∏è  Dur√©e: ${duration}ms`);
        console.log(`üîÑ Drivers recat√©goris√©s: ${this.results.driversRecategorized}`);
        console.log(`üßπ Dossiers nettoy√©s: ${this.results.foldersCleaned}`);
        console.log(`üìÅ Mega mis √† jour: ${this.results.megaUpdated}`);
        console.log(`‚ùå Erreurs: ${this.results.errors.length}`);
        
        if (this.results.errors.length > 0) {
            console.log('\nüö® Erreurs d√©tect√©es:');
            this.results.errors.forEach(error => console.log(`  - ${error}`));
        }
        
        console.log('\nüéØ FINALIZE REFUSION TERMIN√â');
        console.log('‚úÖ Refusion compl√®te et finalis√©e avec succ√®s');
    }
}

// Ex√©cution
const finalizer = new FinalizeRefusion();
finalizer.execute().catch(console.error); 