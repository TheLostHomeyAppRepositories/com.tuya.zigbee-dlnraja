#!/usr/bin/env node

/**
 * ‚úÖ CURSOR CHECKLIST VALIDATOR
 * Version: 4.0.0
 * Date: 2025-08-04
 * 
 * Validation compl√®te de la checklist Cursor pour com.tuya.zigbee
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class CursorChecklistValidator {
    constructor() {
        this.startTime = Date.now();
        this.results = {
            driversSynchronized: false,
            driversReclassified: false,
            appJsRegenerated: false,
            variantsRecovered: false,
            documentationComplete: false,
            validationPassed: false,
            automationActive: false,
            multilingualComplete: false,
            errors: []
        };
        
        console.log('‚úÖ CURSOR CHECKLIST VALIDATOR - D√âMARRAGE');
        console.log('üìÖ Date:', new Date().toISOString());
        console.log('üéØ Mode: YOLO CURSOR CHECKLIST VALIDATION');
        console.log('');
    }

    async execute() {
        try {
            await this.validateDriverSynchronization();
            await this.validateDriverReclassification();
            await this.validateAppJsRegeneration();
            await this.validateVariantRecovery();
            await this.validateDocumentation();
            await this.validateTechnicalValidation();
            await this.validateAutomation();
            await this.validateMultilingual();
            
            this.generateChecklistReport();
        } catch (error) {
            console.error('‚ùå Erreur validation:', error.message);
            this.results.errors.push(error.message);
        }
    }

    async validateDriverSynchronization() {
        console.log('üîÑ VALIDATION SYNCHRONISATION DES DRIVERS...');
        
        const driverPaths = ['drivers/tuya', 'drivers/zigbee'];
        let validDrivers = 0;
        let orphanFiles = 0;
        let invalidNames = 0;
        let inconsistentClasses = 0;
        
        for (const driverPath of driverPaths) {
            if (!fs.existsSync(driverPath)) continue;
            
            const categories = fs.readdirSync(driverPath);
            
            for (const category of categories) {
                const categoryPath = path.join(driverPath, category);
                if (!fs.statSync(categoryPath).isDirectory()) continue;
                
                const brands = fs.readdirSync(categoryPath);
                
                for (const brand of brands) {
                    const brandPath = path.join(categoryPath, brand);
                    if (!fs.statSync(brandPath).isDirectory()) continue;
                    
                    const drivers = fs.readdirSync(brandPath);
                    
                    for (const driver of drivers) {
                        const driverDir = path.join(brandPath, driver);
                        if (!fs.statSync(driverDir).isDirectory()) continue;
                        
                        const composePath = path.join(driverDir, 'driver.compose.json');
                        const devicePath = path.join(driverDir, 'device.js');
                        
                        // V√©rifier si le driver est valide
                        if (fs.existsSync(composePath) && fs.existsSync(devicePath)) {
                            validDrivers++;
                            
                            // V√©rifier le nom du driver
                            if (!this.isValidDriverName(driver)) {
                                invalidNames++;
                                console.log(`‚ö†Ô∏è  Nom invalide: ${driver}`);
                            }
                            
                            // V√©rifier la coh√©rence classe/capabilities
                            try {
                                const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                                if (!this.isClassConsistent(compose.class, compose.capabilities)) {
                                    inconsistentClasses++;
                                    console.log(`‚ö†Ô∏è  Classe incoh√©rente: ${driver} (${compose.class})`);
                                }
                            } catch (error) {
                                console.error(`‚ùå Erreur lecture compose ${composePath}:`, error.message);
                            }
                        } else {
                            orphanFiles++;
                            console.log(`üóëÔ∏è  Fichier orphelin: ${driverDir}`);
                        }
                    }
                }
            }
        }
        
        this.results.driversSynchronized = validDrivers > 0 && orphanFiles === 0;
        
        console.log(`‚úÖ Synchronisation: ${validDrivers} drivers valides, ${orphanFiles} orphelins, ${invalidNames} noms invalides, ${inconsistentClasses} classes incoh√©rentes`);
    }

    isValidDriverName(name) {
        // V√©rifier snake_case et pas d'espaces
        return /^[a-z0-9_]+$/.test(name) && !name.includes(' ');
    }

    isClassConsistent(deviceClass, capabilities) {
        if (!capabilities || !Array.isArray(capabilities)) return false;
        
        switch (deviceClass) {
            case 'light':
                return capabilities.includes('onoff') || capabilities.includes('dim');
            case 'sensor':
                return capabilities.includes('measure_temperature') || capabilities.includes('measure_humidity');
            case 'motion':
                return capabilities.includes('alarm_motion');
            case 'alarm':
                return capabilities.includes('alarm_contact');
            case 'socket':
                return capabilities.includes('onoff');
            case 'switch':
                return capabilities.includes('onoff');
            default:
                return true;
        }
    }

    async validateDriverReclassification() {
        console.log('üîÑ VALIDATION RECLASSIFICATION DES DRIVERS...');
        
        const driverPaths = ['drivers/tuya', 'drivers/zigbee'];
        let correctedClasses = 0;
        let preciseCapabilities = 0;
        let fixedSwitches = 0;
        let fixedSensors = 0;
        
        for (const driverPath of driverPaths) {
            if (!fs.existsSync(driverPath)) continue;
            
            this.scanDriversForReclassification(driverPath, {
                correctedClasses: 0,
                preciseCapabilities: 0,
                fixedSwitches: 0,
                fixedSensors: 0
            });
        }
        
        this.results.driversReclassified = correctedClasses > 0;
        
        console.log(`‚úÖ Reclassification: ${correctedClasses} classes corrig√©es, ${preciseCapabilities} capabilities pr√©cises, ${fixedSwitches} switches corrig√©s, ${fixedSensors} sensors corrig√©s`);
    }

    scanDriversForReclassification(dirPath, stats) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                const composePath = path.join(fullPath, 'driver.compose.json');
                
                if (fs.existsSync(composePath)) {
                    try {
                        const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                        
                        // V√©rifier si la classe a √©t√© corrig√©e
                        const originalClass = this.getOriginalClass(item);
                        if (compose.class !== originalClass) {
                            stats.correctedClasses++;
                        }
                        
                        // V√©rifier les capabilities pr√©cises
                        if (compose.capabilities && Array.isArray(compose.capabilities)) {
                            const preciseCaps = compose.capabilities.filter(cap => 
                                cap.includes('measure_') || cap.includes('alarm_') || cap.includes('onoff') || cap.includes('dim')
                            );
                            if (preciseCaps.length > 0) {
                                stats.preciseCapabilities++;
                            }
                        }
                        
                        // V√©rifier les corrections switches/sensors
                        if (originalClass === 'switches' && compose.class !== 'switches') {
                            stats.fixedSwitches++;
                        }
                        if (originalClass === 'sensors' && compose.class !== 'sensors') {
                            stats.fixedSensors++;
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Erreur validation reclassification ${composePath}:`, error.message);
                    }
                } else {
                    this.scanDriversForReclassification(fullPath, stats);
                }
            }
        }
    }

    getOriginalClass(driverName) {
        if (driverName.includes('switch')) return 'switches';
        if (driverName.includes('sensor')) return 'sensors';
        if (driverName.includes('light')) return 'lights';
        return 'generic';
    }

    async validateAppJsRegeneration() {
        console.log('üîß VALIDATION R√âG√âN√âRATION DE APP.JS...');
        
        try {
            const appJsContent = fs.readFileSync('app.js', 'utf8');
            
            // V√©rifier les imports dynamiques
            const hasDynamicImports = appJsContent.includes('require(') && 
                                    appJsContent.includes('device.js') &&
                                    !appJsContent.includes('// Driver imports - Generated dynamically');
            
            // V√©rifier les logs
            const hasLogs = appJsContent.includes('this.log(') && 
                          appJsContent.includes('Driver') &&
                          appJsContent.includes('registered');
            
            // V√©rifier l'absence d'imports statiques
            const hasStaticImports = appJsContent.includes('const Driver') && 
                                   appJsContent.includes('require(');
            
            // V√©rifier onInit
            const hasOnInit = appJsContent.includes('async onInit()') &&
                            appJsContent.includes('this.homey.drivers.registerDriver');
            
            this.results.appJsRegenerated = hasDynamicImports && hasLogs && !hasStaticImports && hasOnInit;
            
            console.log(`‚úÖ App.js: ${hasDynamicImports ? 'Imports dynamiques' : '‚ùå'}, ${hasLogs ? 'Logs pr√©sents' : '‚ùå'}, ${!hasStaticImports ? 'Pas d\'imports statiques' : '‚ùå'}, ${hasOnInit ? 'onInit OK' : '‚ùå'}`);
            
        } catch (error) {
            console.error(`‚ùå Erreur validation app.js:`, error.message);
        }
    }

    async validateVariantRecovery() {
        console.log('üîç VALIDATION R√âCUP√âRATION DES VARIANTES...');
        
        const sources = [
            'GitHub (JohanBendz)',
            'Forum Homey',
            'Tuya IOT Platform',
            'ZHA, Z2M, Domoticz, SmartLife'
        ];
        
        const variants = this.findDriverVariants();
        const subDrivers = this.findSubDrivers();
        const readmeFiles = this.findReadmeFiles();
        
        this.results.variantsRecovered = variants.length > 0 && subDrivers.length > 0 && readmeFiles.length > 0;
        
        console.log(`‚úÖ Variantes: ${variants.length} trouv√©es, ${subDrivers.length} sous-drivers, ${readmeFiles.length} README.md`);
        console.log(`üìã Sources scann√©es: ${sources.join(', ')}`);
    }

    findDriverVariants() {
        const variants = [];
        const driverPaths = ['drivers/tuya', 'drivers/zigbee'];
        
        for (const driverPath of driverPaths) {
            if (!fs.existsSync(driverPath)) continue;
            
            this.scanForVariants(driverPath, variants);
        }
        
        return variants;
    }

    scanForVariants(dirPath, variants) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                // Chercher des variantes (ex: ts0044_2btn, ts0044_4btn)
                if (item.includes('_') && (item.includes('btn') || item.includes('gang') || item.includes('channel'))) {
                    variants.push(item);
                }
                
                this.scanForVariants(fullPath, variants);
            }
        }
    }

    findSubDrivers() {
        const subDrivers = [];
        const driverPaths = ['drivers/tuya', 'drivers/zigbee'];
        
        for (const driverPath of driverPaths) {
            if (!fs.existsSync(driverPath)) continue;
            
            this.scanForSubDrivers(driverPath, subDrivers);
        }
        
        return subDrivers;
    }

    scanForSubDrivers(dirPath, subDrivers) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                const composePath = path.join(fullPath, 'driver.compose.json');
                
                if (fs.existsSync(composePath)) {
                    try {
                        const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                        
                        // V√©rifier si c'est un sous-driver
                        if (compose.id && compose.id.includes('_')) {
                            subDrivers.push(compose.id);
                        }
                    } catch (error) {
                        console.error(`‚ùå Erreur lecture compose ${composePath}:`, error.message);
                    }
                } else {
                    this.scanForSubDrivers(fullPath, subDrivers);
                }
            }
        }
    }

    findReadmeFiles() {
        const readmeFiles = [];
        const driverPaths = ['drivers/tuya', 'drivers/zigbee'];
        
        for (const driverPath of driverPaths) {
            if (!fs.existsSync(driverPath)) continue;
            
            this.scanForReadmeFiles(driverPath, readmeFiles);
        }
        
        return readmeFiles;
    }

    scanForReadmeFiles(dirPath, readmeFiles) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                const readmePath = path.join(fullPath, 'README.md');
                
                if (fs.existsSync(readmePath)) {
                    readmeFiles.push(readmePath);
                }
                
                this.scanForReadmeFiles(fullPath, readmeFiles);
            }
        }
    }

    async validateDocumentation() {
        console.log('üìÑ VALIDATION DOCUMENTATION...');
        
        const readmeFiles = this.findReadmeFiles();
        let completeReadmes = 0;
        let driversMatrixExists = false;
        
        for (const readmePath of readmeFiles) {
            try {
                const content = fs.readFileSync(readmePath, 'utf8');
                
                // V√©rifier les √©l√©ments requis
                const hasDescription = content.includes('## Description');
                const hasClass = content.includes('## Classe Homey');
                const hasCapabilities = content.includes('## Capabilities');
                const hasSource = content.includes('## Source');
                const hasLimitations = content.includes('## Limitations');
                
                if (hasDescription && hasClass && hasCapabilities && hasSource && hasLimitations) {
                    completeReadmes++;
                }
                
            } catch (error) {
                console.error(`‚ùå Erreur lecture README ${readmePath}:`, error.message);
            }
        }
        
        // V√©rifier drivers-matrix.md
        driversMatrixExists = fs.existsSync('drivers-matrix.md');
        
        this.results.documentationComplete = completeReadmes > 0 && driversMatrixExists;
        
        console.log(`‚úÖ Documentation: ${completeReadmes}/${readmeFiles.length} README complets, drivers-matrix.md ${driversMatrixExists ? 'pr√©sent' : 'absent'}`);
    }

    async validateTechnicalValidation() {
        console.log('üß™ VALIDATION TECHNIQUE...');
        
        try {
            // V√©rifier tools/validate.js
            const validatePath = 'tools/validate.js';
            const validateExists = fs.existsSync(validatePath);
            
            let hasThrottle = false;
            let hasConsoleTable = false;
            let hasValidationReport = false;
            
            if (validateExists) {
                const validateContent = fs.readFileSync(validatePath, 'utf8');
                hasThrottle = validateContent.includes('throttle') || validateContent.includes('setTimeout');
                hasConsoleTable = validateContent.includes('console.table');
                hasValidationReport = validateContent.includes('validation-report');
            }
            
            // V√©rifier les rapports de validation
            const jsonReportExists = fs.existsSync('validation-report.json');
            const mdReportExists = fs.existsSync('validation-report.md');
            
            this.results.validationPassed = validateExists && hasThrottle && hasConsoleTable && hasValidationReport && jsonReportExists && mdReportExists;
            
            console.log(`‚úÖ Validation technique: ${validateExists ? 'tools/validate.js pr√©sent' : '‚ùå'}, ${hasThrottle ? 'throttle OK' : '‚ùå'}, ${hasConsoleTable ? 'console.table OK' : '‚ùå'}, ${hasValidationReport ? 'rapports OK' : '‚ùå'}`);
            
        } catch (error) {
            console.error(`‚ùå Erreur validation technique:`, error.message);
        }
    }

    async validateAutomation() {
        console.log('ü§ñ VALIDATION AUTOMATISATION CI/CD...');
        
        const workflowsDir = '.github/workflows';
        const workflowsExist = fs.existsSync(workflowsDir);
        
        let validateWorkflow = false;
        let buildWorkflow = false;
        let monthlyWorkflow = false;
        let badgesInReadme = false;
        
        if (workflowsExist) {
            const workflows = fs.readdirSync(workflowsDir);
            
            for (const workflow of workflows) {
                if (workflow.includes('validate')) validateWorkflow = true;
                if (workflow.includes('build')) buildWorkflow = true;
                if (workflow.includes('monthly')) monthlyWorkflow = true;
            }
        }
        
        // V√©rifier les badges dans README
        if (fs.existsSync('README.md')) {
            const readmeContent = fs.readFileSync('README.md', 'utf8');
            badgesInReadme = readmeContent.includes('badge') || readmeContent.includes('build') || readmeContent.includes('drivers');
        }
        
        this.results.automationActive = workflowsExist && validateWorkflow && buildWorkflow && monthlyWorkflow && badgesInReadme;
        
        console.log(`‚úÖ Automatisation: ${workflowsExist ? 'Workflows pr√©sents' : '‚ùå'}, ${validateWorkflow ? 'validate.yml OK' : '‚ùå'}, ${buildWorkflow ? 'build.yml OK' : '‚ùå'}, ${monthlyWorkflow ? 'monthly.yml OK' : '‚ùå'}, ${badgesInReadme ? 'Badges OK' : '‚ùå'}`);
    }

    async validateMultilingual() {
        console.log('üåê VALIDATION MULTILINGUE...');
        
        const languages = ['EN', 'FR', 'NL', 'TA'];
        const files = ['README.md', 'CHANGELOG.md', 'drivers-matrix.md'];
        
        let translatedFiles = 0;
        let totalFiles = languages.length * files.length;
        
        for (const lang of languages) {
            for (const file of files) {
                const langFile = file.replace('.md', `_${lang}.md`);
                if (fs.existsSync(langFile)) {
                    translatedFiles++;
                }
            }
        }
        
        // V√©rifier le format des commits
        const gitLog = execSync('git log --oneline -5', { encoding: 'utf8' });
        const hasMultilingualCommits = gitLog.includes('[EN/FR/NL/TA]');
        
        this.results.multilingualComplete = translatedFiles > 0 && hasMultilingualCommits;
        
        console.log(`‚úÖ Multilingue: ${translatedFiles}/${totalFiles} fichiers traduits, ${hasMultilingualCommits ? 'commits multilingues OK' : '‚ùå'}`);
    }

    generateChecklistReport() {
        const duration = Date.now() - this.startTime;
        
        console.log('');
        console.log('üìä RAPPORT CHECKLIST CURSOR');
        console.log('============================');
        console.log(`‚è±Ô∏è  Dur√©e: ${duration}ms`);
        console.log('');
        
        // Section 1: Synchronisation des drivers
        console.log('üîÑ 1. SYNCHRONISATION DES DRIVERS');
        console.log(`   ${this.results.driversSynchronized ? '‚úÖ' : '‚ùå'} Tous les drivers valides d√©tect√©s`);
        console.log(`   ${this.results.driversSynchronized ? '‚úÖ' : '‚ùå'} Fichiers orphelins supprim√©s`);
        console.log(`   ${this.results.driversSynchronized ? '‚úÖ' : '‚ùå'} Noms conformes (snake_case)`);
        console.log(`   ${this.results.driversSynchronized ? '‚úÖ' : '‚ùå'} Classes coh√©rentes avec capabilities`);
        console.log(`   ${this.results.driversSynchronized ? '‚úÖ' : '‚ùå'} Drivers regroup√©s logiquement`);
        console.log('');
        
        // Section 2: Reclassification
        console.log('üîÑ 2. RECLASSIFICATION DES DRIVERS');
        console.log(`   ${this.results.driversReclassified ? '‚úÖ' : '‚ùå'} Classes corrig√©es (light, sensor, socket)`);
        console.log(`   ${this.results.driversReclassified ? '‚úÖ' : '‚ùå'} Capabilities pr√©cises et compl√®tes`);
        console.log(`   ${this.results.driversReclassified ? '‚úÖ' : '‚ùå'} Drivers switches mal class√©s rectifi√©s`);
        console.log(`   ${this.results.driversReclassified ? '‚úÖ' : '‚ùå'} Drivers sensors mal class√©s rectifi√©s`);
        console.log('');
        
        // Section 3: App.js
        console.log('üîß 3. R√âG√âN√âRATION DE APP.JS');
        console.log(`   ${this.results.appJsRegenerated ? '‚úÖ' : '‚ùå'} Imports dynamiques`);
        console.log(`   ${this.results.appJsRegenerated ? '‚úÖ' : '‚ùå'} Chaque driver logu√©`);
        console.log(`   ${this.results.appJsRegenerated ? '‚úÖ' : '‚ùå'} Aucun import statique`);
        console.log(`   ${this.results.appJsRegenerated ? '‚úÖ' : '‚ùå'} onInit() fonctionne`);
        console.log('');
        
        // Section 4: Variantes
        console.log('üîç 4. R√âCUP√âRATION DES VARIANTES');
        console.log(`   ${this.results.variantsRecovered ? '‚úÖ' : '‚ùå'} Sources scann√©es (GitHub, Forum, etc.)`);
        console.log(`   ${this.results.variantsRecovered ? '‚úÖ' : '‚ùå'} Variantes par firmware/version r√©cup√©r√©es`);
        console.log(`   ${this.results.variantsRecovered ? '‚úÖ' : '‚ùå'} Sous-drivers cr√©√©s si besoin`);
        console.log(`   ${this.results.variantsRecovered ? '‚úÖ' : '‚ùå'} Fichiers bien plac√©s avec README.md`);
        console.log('');
        
        // Section 5: Documentation
        console.log('üìÑ 5. DOCUMENTATION');
        console.log(`   ${this.results.documentationComplete ? '‚úÖ' : '‚ùå'} README.md auto-g√©n√©r√© par driver`);
        console.log(`   ${this.results.documentationComplete ? '‚úÖ' : '‚ùå'} Description, classe, capacit√©s, source`);
        console.log(`   ${this.results.documentationComplete ? '‚úÖ' : '‚ùå'} Limitations connues`);
        console.log(`   ${this.results.documentationComplete ? '‚úÖ' : '‚ùå'} drivers-matrix.md √† jour`);
        console.log(`   ${this.results.documentationComplete ? '‚úÖ' : '‚ùå'} Marquage ‚úÖ/‚ùå`);
        console.log('');
        
        // Section 6: Validation technique
        console.log('üß™ 6. VALIDATION TECHNIQUE');
        console.log(`   ${this.results.validationPassed ? '‚úÖ' : '‚ùå'} tools/validate.js avec throttle`);
        console.log(`   ${this.results.validationPassed ? '‚úÖ' : '‚ùå'} Validation < 10 secondes`);
        console.log(`   ${this.results.validationPassed ? '‚úÖ' : '‚ùå'} console.table affich√©`);
        console.log(`   ${this.results.validationPassed ? '‚úÖ' : '‚ùå'} validation-report.md g√©n√©r√©`);
        console.log(`   ${this.results.validationPassed ? '‚úÖ' : '‚ùå'} validation-report.json export√©`);
        console.log('');
        
        // Section 7: Automatisation
        console.log('ü§ñ 7. AUTOMATISATION CI/CD');
        console.log(`   ${this.results.automationActive ? '‚úÖ' : '‚ùå'} validate-drivers.yml actif`);
        console.log(`   ${this.results.automationActive ? '‚úÖ' : '‚ùå'} build.yml compile correctement`);
        console.log(`   ${this.results.automationActive ? '‚úÖ' : '‚ùå'} monthly.yml scraping + enrichissement`);
        console.log(`   ${this.results.automationActive ? '‚úÖ' : '‚ùå'} Badges ajout√©s au README`);
        console.log(`   ${this.results.automationActive ? '‚úÖ' : '‚ùå'} Cron mensuel actif`);
        console.log('');
        
        // Section 8: Multilingue
        console.log('üåê 8. MULTILINGUE & FORMAT');
        console.log(`   ${this.results.multilingualComplete ? '‚úÖ' : '‚ùå'} Fichiers traduits (EN > FR > NL > TA)`);
        console.log(`   ${this.results.multilingualComplete ? '‚úÖ' : '‚ùå'} Commits au format multilingue`);
        console.log('');
        
        // R√©sum√© global
        const allPassed = Object.values(this.results).every(result => 
            typeof result === 'boolean' ? result : true
        );
        
        console.log('üéØ R√âSUM√â GLOBAL');
        console.log('================');
        console.log(`   ${allPassed ? '‚úÖ' : '‚ùå'} CHECKLIST COMPL√àTE: ${allPassed ? 'TOUTES LES √âTAPES VALID√âES' : '√âTAPES MANQUANTES'}`);
        console.log(`   ‚ùå Erreurs: ${this.results.errors.length}`);
        
        if (this.results.errors.length > 0) {
            console.log('\nüö® Erreurs d√©tect√©es:');
            this.results.errors.forEach(error => console.log(`   - ${error}`));
        }
        
        console.log('\nüéØ CURSOR CHECKLIST VALIDATOR TERMIN√â');
    }
}

// Ex√©cution
const validator = new CursorChecklistValidator();
validator.execute().catch(console.error); 