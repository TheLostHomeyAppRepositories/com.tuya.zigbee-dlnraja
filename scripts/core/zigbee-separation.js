#!/usr/bin/env node

/**
 * üîÑ ZIGBEE SEPARATION
 * Version: 1.0.0
 * Date: 2025-08-05
 * 
 * S√©paration des drivers Tuya et Zigbee g√©n√©riques
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ZigbeeSeparation {
    constructor() {
        this.startTime = Date.now();
        this.results = {
            tuyaDrivers: 0,
            zigbeeDrivers: 0,
            driversAnalyzed: 0,
            errors: []
        };
        
        console.log('üîÑ ZIGBEE SEPARATION - D√âMARRAGE');
        console.log('üìÖ Date:', new Date().toISOString());
        console.log('üéØ Mode: YOLO ZIGBEE SEPARATION');
        console.log('');
    }

    async execute() {
        try {
            await this.analyzeAllDrivers();
            await this.createZigbeeStructure();
            await this.separateDrivers();
            await this.updateComposeFiles();
            await this.generateSeparationReport();
            await this.commitSeparation();
            
            this.generateReport();
        } catch (error) {
            console.error('‚ùå Erreur s√©paration:', error.message);
            this.results.errors.push(error.message);
        }
    }

    async analyzeAllDrivers() {
        console.log('üîç ANALYSE DE TOUS LES DRIVERS...');
        
        try {
            this.tuyaDrivers = [];
            this.zigbeeDrivers = [];
            
            const categories = ['controls', 'covers', 'historical', 'lights', 'locks', 'plugs', 'sensors', 'smart-life', 'switches', 'thermostats'];
            
            for (const category of categories) {
                const categoryPath = `drivers/tuya/${category}`;
                if (fs.existsSync(categoryPath)) {
                    const items = fs.readdirSync(categoryPath);
                    
                    for (const item of items) {
                        const driverPath = path.join(categoryPath, item);
                        const driverStat = fs.statSync(driverPath);
                        
                        if (driverStat.isDirectory()) {
                            await this.analyzeDriver(category, item);
                        }
                    }
                }
            }
            
            console.log(`‚úÖ ${this.results.driversAnalyzed} drivers analys√©s`);

        } catch (error) {
            console.error('‚ùå Erreur analyse drivers:', error.message);
            this.results.errors.push(`Driver analysis: ${error.message}`);
        }
    }

    async analyzeDriver(category, driverName) {
        try {
            const driverPath = `drivers/tuya/${category}/${driverName}`;
            const deviceJsPath = path.join(driverPath, 'device.js');
            const composePath = path.join(driverPath, 'driver.compose.json');
            
            let isTuyaDriver = false;
            let isZigbeeDriver = false;
            
            // Analyser device.js
            if (fs.existsSync(deviceJsPath)) {
                const deviceContent = fs.readFileSync(deviceJsPath, 'utf8');
                
                // D√©tecter les marqueurs Tuya
                if (deviceContent.includes('TuyaDevice') || 
                    deviceContent.includes('tuya') || 
                    deviceContent.includes('DP') ||
                    deviceContent.includes('DataPoint') ||
                    deviceContent.includes('manufacturername') ||
                    driverName.toLowerCase().includes('tuya')) {
                    isTuyaDriver = true;
                }
                
                // D√©tecter les marqueurs Zigbee g√©n√©rique
                if (deviceContent.includes('ZigbeeDevice') ||
                    deviceContent.includes('zigbee') ||
                    deviceContent.includes('cluster') ||
                    deviceContent.includes('endpoint') ||
                    driverName.toLowerCase().includes('zigbee') ||
                    driverName.toLowerCase().includes('generic') ||
                    driverName.toLowerCase().includes('ikea') ||
                    driverName.toLowerCase().includes('philips') ||
                    driverName.toLowerCase().includes('osram') ||
                    driverName.toLowerCase().includes('xiaomi')) {
                    isZigbeeDriver = true;
                }
            }
            
            // Analyser driver.compose.json
            if (fs.existsSync(composePath)) {
                try {
                    const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                    
                    if (compose.manufacturer && compose.manufacturer.toLowerCase().includes('tuya')) {
                        isTuyaDriver = true;
                    }
                    
                    if (compose.manufacturer && (
                        compose.manufacturer.toLowerCase().includes('ikea') ||
                        compose.manufacturer.toLowerCase().includes('philips') ||
                        compose.manufacturer.toLowerCase().includes('osram') ||
                        compose.manufacturer.toLowerCase().includes('xiaomi') ||
                        compose.manufacturer.toLowerCase().includes('generic')
                    )) {
                        isZigbeeDriver = true;
                    }
                } catch (error) {
                    console.error(`‚ùå Erreur lecture compose ${driverName}:`, error.message);
                }
            }
            
            // Logique de d√©cision
            if (isTuyaDriver && !isZigbeeDriver) {
                this.tuyaDrivers.push({ category, name: driverName, path: driverPath });
                console.log(`‚úÖ Tuya driver: ${category}/${driverName}`);
            } else if (isZigbeeDriver || (!isTuyaDriver && !isZigbeeDriver)) {
                this.zigbeeDrivers.push({ category, name: driverName, path: driverPath });
                console.log(`üîó Zigbee driver: ${category}/${driverName}`);
            } else {
                // Par d√©faut, consid√©rer comme Tuya
                this.tuyaDrivers.push({ category, name: driverName, path: driverPath });
                console.log(`‚úÖ Tuya driver (d√©faut): ${category}/${driverName}`);
            }
            
            this.results.driversAnalyzed++;

        } catch (error) {
            console.error(`‚ùå Erreur analyse ${category}/${driverName}:`, error.message);
        }
    }

    async createZigbeeStructure() {
        console.log('üìÅ CR√âATION DE LA STRUCTURE ZIGBEE...');
        
        try {
            // Cr√©er la structure zigbee
            const zigbeeCategories = ['lights', 'sensors', 'controls', 'covers', 'locks', 'historical'];
            
            for (const category of zigbeeCategories) {
                const categoryPath = `drivers/zigbee/${category}`;
                fs.mkdirSync(categoryPath, { recursive: true });
            }
            
            console.log('‚úÖ Structure zigbee cr√©√©e');

        } catch (error) {
            console.error('‚ùå Erreur cr√©ation structure zigbee:', error.message);
        }
    }

    async separateDrivers() {
        console.log('üîÑ S√âPARATION DES DRIVERS...');
        
        try {
            // D√©placer les drivers Zigbee
            for (const driver of this.zigbeeDrivers) {
                await this.moveDriverToZigbee(driver);
            }
            
            // R√©organiser les drivers Tuya restants
            await this.reorganizeTuyaDrivers();
            
            console.log(`‚úÖ ${this.zigbeeDrivers.length} drivers d√©plac√©s vers zigbee`);
            console.log(`‚úÖ ${this.tuyaDrivers.length} drivers restent dans tuya`);

        } catch (error) {
            console.error('‚ùå Erreur s√©paration:', error.message);
            this.results.errors.push(`Separation: ${error.message}`);
        }
    }

    async moveDriverToZigbee(driver) {
        try {
            const sourcePath = driver.path;
            const targetCategory = this.mapToZigbeeCategory(driver.category);
            const targetPath = `drivers/zigbee/${targetCategory}/${driver.name}`;
            
            // D√©placer le driver
            this.moveFolderRecursively(sourcePath, targetPath);
            
            console.log(`‚úÖ Driver d√©plac√©: ${driver.category}/${driver.name} ‚Üí zigbee/${targetCategory}/${driver.name}`);
            this.results.zigbeeDrivers++;

        } catch (error) {
            console.error(`‚ùå Erreur d√©placement ${driver.name}:`, error.message);
        }
    }

    mapToZigbeeCategory(tuyaCategory) {
        const mapping = {
            'lights': 'lights',
            'switches': 'controls',
            'plugs': 'controls',
            'sensors': 'sensors',
            'covers': 'covers',
            'locks': 'locks',
            'thermostats': 'sensors',
            'controls': 'controls',
            'smart-life': 'lights',
            'historical': 'historical'
        };
        
        return mapping[tuyaCategory] || 'controls';
    }

    async reorganizeTuyaDrivers() {
        console.log('üîÑ R√©organisation des drivers Tuya...');
        
        try {
            // Supprimer les cat√©gories vides
            const categories = ['controls', 'covers', 'historical', 'lights', 'locks', 'plugs', 'sensors', 'smart-life', 'switches', 'thermostats'];
            
            for (const category of categories) {
                const categoryPath = `drivers/tuya/${category}`;
                if (fs.existsSync(categoryPath)) {
                    const items = fs.readdirSync(categoryPath);
                    if (items.length === 0) {
                        fs.rmdirSync(categoryPath);
                        console.log(`üóëÔ∏è  Cat√©gorie vide supprim√©e: ${category}`);
                    }
                }
            }
            
            console.log('‚úÖ Drivers Tuya r√©organis√©s');

        } catch (error) {
            console.error('‚ùå Erreur r√©organisation Tuya:', error.message);
        }
    }

    async updateComposeFiles() {
        console.log('üìù MISE √Ä JOUR DES FICHIERS COMPOSE...');
        
        try {
            // Mettre √† jour les drivers Zigbee
            await this.updateZigbeeComposeFiles();
            
            // Mettre √† jour les drivers Tuya
            await this.updateTuyaComposeFiles();
            
            console.log('‚úÖ Fichiers compose mis √† jour');

        } catch (error) {
            console.error('‚ùå Erreur mise √† jour compose:', error.message);
            this.results.errors.push(`Compose update: ${error.message}`);
        }
    }

    async updateZigbeeComposeFiles() {
        try {
            const zigbeeCategories = ['lights', 'sensors', 'controls', 'covers', 'locks', 'historical'];
            
            for (const category of zigbeeCategories) {
                const categoryPath = `drivers/zigbee/${category}`;
                if (fs.existsSync(categoryPath)) {
                    const items = fs.readdirSync(categoryPath);
                    
                    for (const item of items) {
                        const composePath = path.join(categoryPath, item, 'driver.compose.json');
                        
                        if (fs.existsSync(composePath)) {
                            try {
                                const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                                
                                // Mettre √† jour pour Zigbee g√©n√©rique
                                compose.isGeneric = true;
                                compose.source = 'zigbee-common';
                                compose.type = 'zigbee';
                                
                                if (!compose.manufacturer) {
                                    compose.manufacturer = 'Generic';
                                }
                                
                                fs.writeFileSync(composePath, JSON.stringify(compose, null, 2));
                                console.log(`‚úÖ Compose mis √† jour: zigbee/${category}/${item}`);
                                
                            } catch (error) {
                                console.error(`‚ùå Erreur mise √† jour compose ${item}:`, error.message);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå Erreur mise √† jour compose zigbee:', error.message);
        }
    }

    async updateTuyaComposeFiles() {
        try {
            const tuyaCategories = ['lights', 'switches', 'plugs', 'sensors', 'covers', 'locks', 'thermostats'];
            
            for (const category of tuyaCategories) {
                const categoryPath = `drivers/tuya/${category}`;
                if (fs.existsSync(categoryPath)) {
                    const items = fs.readdirSync(categoryPath);
                    
                    for (const item of items) {
                        const composePath = path.join(categoryPath, item, 'driver.compose.json');
                        
                        if (fs.existsSync(composePath)) {
                            try {
                                const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                                
                                // Mettre √† jour pour Tuya
                                compose.isGeneric = false;
                                compose.source = 'tuya-zigbee';
                                compose.type = 'tuya';
                                
                                if (!compose.manufacturer) {
                                    compose.manufacturer = 'Tuya';
                                }
                                
                                fs.writeFileSync(composePath, JSON.stringify(compose, null, 2));
                                console.log(`‚úÖ Compose mis √† jour: tuya/${category}/${item}`);
                                
                            } catch (error) {
                                console.error(`‚ùå Erreur mise √† jour compose ${item}:`, error.message);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå Erreur mise √† jour compose tuya:', error.message);
        }
    }

    async generateSeparationReport() {
        console.log('üìä G√âN√âRATION DU RAPPORT DE S√âPARATION...');
        
        try {
            const report = {
                timestamp: new Date().toISOString(),
                separation: {
                    tuyaDrivers: this.tuyaDrivers.length,
                    zigbeeDrivers: this.zigbeeDrivers.length,
                    totalDrivers: this.results.driversAnalyzed
                },
                tuyaDrivers: this.tuyaDrivers.map(d => `${d.category}/${d.name}`),
                zigbeeDrivers: this.zigbeeDrivers.map(d => `${d.category}/${d.name}`),
                errors: this.results.errors
            };
            
            fs.writeFileSync('zigbee-separation-report.json', JSON.stringify(report, null, 2));
            
            // G√©n√©rer rapport markdown
            const markdownReport = this.generateMarkdownReport(report);
            fs.writeFileSync('zigbee-separation-report.md', markdownReport);
            
            console.log('‚úÖ Rapport de s√©paration g√©n√©r√©');

        } catch (error) {
            console.error('‚ùå Erreur g√©n√©ration rapport:', error.message);
        }
    }

    generateMarkdownReport(report) {
        return `# üîÑ ZIGBEE SEPARATION REPORT

## üìä Statistiques
- **Total drivers analys√©s**: ${report.separation.totalDrivers}
- **Drivers Tuya**: ${report.separation.tuyaDrivers}
- **Drivers Zigbee**: ${report.separation.zigbeeDrivers}

## üìÅ Drivers Tuya
${report.tuyaDrivers.map(d => `- ${d}`).join('\n')}

## üîó Drivers Zigbee
${report.zigbeeDrivers.map(d => `- ${d}`).join('\n')}

## üéØ R√©sultat
S√©paration r√©ussie avec ${report.separation.zigbeeDrivers} drivers d√©plac√©s vers zigbee/ et ${report.separation.tuyaDrivers} drivers restant dans tuya/.

## üìÖ Date
${report.timestamp}
`;
    }

    async commitSeparation() {
        console.log('üíæ COMMIT DE LA S√âPARATION...');
        
        try {
            execSync('git add .', { stdio: 'pipe' });
            execSync('git commit -m "üîÑ ZIGBEE SEPARATION [EN/FR/NL/TA] - Version 1.0.0 - S√©paration drivers Tuya/Zigbee + Cr√©ation structure zigbee/ + Mise √† jour compose files + Rapport de s√©paration + Organisation optimale"', { stdio: 'pipe' });
            execSync('git push origin master', { stdio: 'pipe' });
            console.log('‚úÖ S√©paration commit√©e et pouss√©e');
        } catch (error) {
            console.error('‚ùå Erreur commit:', error.message);
        }
    }

    moveFolderRecursively(sourcePath, targetPath) {
        if (fs.existsSync(sourcePath)) {
            fs.mkdirSync(path.dirname(targetPath), { recursive: true });
            
            const items = fs.readdirSync(sourcePath);
            
            for (const item of items) {
                const sourceItem = path.join(sourcePath, item);
                const targetItem = path.join(targetPath, item);
                
                if (fs.statSync(sourceItem).isDirectory()) {
                    this.moveFolderRecursively(sourceItem, targetItem);
                } else {
                    fs.copyFileSync(sourceItem, targetItem);
                }
            }
            
            this.removeFolderRecursively(sourcePath);
        }
    }

    removeFolderRecursively(folderPath) {
        if (fs.existsSync(folderPath)) {
            const items = fs.readdirSync(folderPath);
            
            for (const item of items) {
                const itemPath = path.join(folderPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    this.removeFolderRecursively(itemPath);
                } else {
                    fs.unlinkSync(itemPath);
                }
            }
            
            fs.rmdirSync(folderPath);
        }
    }

    generateReport() {
        const duration = Date.now() - this.startTime;
        
        console.log('');
        console.log('üìä RAPPORT ZIGBEE SEPARATION');
        console.log('==============================');
        console.log(`‚è±Ô∏è  Dur√©e: ${duration}ms`);
        console.log(`üîç Drivers analys√©s: ${this.results.driversAnalyzed}`);
        console.log(`‚úÖ Drivers Tuya: ${this.results.tuyaDrivers}`);
        console.log(`üîó Drivers Zigbee: ${this.results.zigbeeDrivers}`);
        console.log(`üö® Erreurs: ${this.results.errors.length}`);
        
        if (this.results.errors.length > 0) {
            console.log('\nüö® Erreurs d√©tect√©es:');
            this.results.errors.forEach(error => console.log(`  - ${error}`));
        }
        
        console.log('\nüéØ ZIGBEE SEPARATION TERMIN√â');
        console.log('‚úÖ S√©paration r√©ussie');
    }
}

// Ex√©cution
const separation = new ZigbeeSeparation();
separation.execute().catch(console.error); 