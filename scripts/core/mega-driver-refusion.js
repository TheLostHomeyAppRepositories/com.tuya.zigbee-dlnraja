#!/usr/bin/env node

/**
 * üîÑ MEGA DRIVER REFUSION
 * Version: 1.0.0
 * Date: 2025-08-05
 * 
 * Refusion compl√®te de tous les drivers avec r√©cup√©ration des anciens drivers
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class MegaDriverRefusion {
    constructor() {
        this.startTime = Date.now();
        this.results = {
            driversRecovered: 0,
            driversFused: 0,
            oldDriversFound: 0,
            structureUpdated: 0,
            errors: []
        };
        
        this.allDrivers = [];
        this.recoveredDrivers = [];
        this.fusedDrivers = [];
        
        console.log('üîÑ MEGA DRIVER REFUSION - D√âMARRAGE');
        console.log('üìÖ Date:', new Date().toISOString());
        console.log('üéØ Mode: YOLO MEGA REFUSION');
        console.log('');
    }

    async execute() {
        try {
            await this.recoverOldDrivers();
            await this.scanCurrentDrivers();
            await this.fuseAllDrivers();
            await this.cleanupDriverStructure();
            await this.updateMegaStructure();
            await this.commitRefusion();
            
            this.generateReport();
        } catch (error) {
            console.error('‚ùå Erreur mega refusion:', error.message);
            this.results.errors.push(error.message);
        }
    }

    async recoverOldDrivers() {
        console.log('üîç R√âCUP√âRATION DES ANCIENS DRIVERS...');
        
        try {
            // R√©cup√©rer les drivers de la branche tuya-light
            await this.recoverFromBranch('tuya-light');
            
            // R√©cup√©rer les drivers de l'historique master
            await this.recoverFromGitHistory();
            
            // R√©cup√©rer les drivers des dossiers fused et recovered
            await this.recoverFromFusedFolders();
            
            this.results.oldDriversFound = this.recoveredDrivers.length;
            console.log(`‚úÖ ${this.recoveredDrivers.length} anciens drivers r√©cup√©r√©s`);

        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration anciens drivers:', error.message);
            this.results.errors.push(`Old drivers recovery: ${error.message}`);
        }
    }

    async recoverFromBranch(branchName) {
        try {
            console.log(`üì• R√©cup√©ration depuis la branche ${branchName}...`);
            
            // Lister les fichiers drivers dans la branche
            const output = execSync(`git ls-tree -r --name-only origin/${branchName} | grep "drivers/"`, { encoding: 'utf8' });
            const files = output.split('\n').filter(line => line.includes('device.js') || line.includes('driver.compose.json'));
            
            for (const file of files) {
                try {
                    // R√©cup√©rer le contenu du fichier
                    const content = execSync(`git show origin/${branchName}:${file}`, { encoding: 'utf8' });
                    
                    // Extraire les informations du driver
                    const driverInfo = this.extractDriverInfo(file, content);
                    if (driverInfo) {
                        this.recoveredDrivers.push(driverInfo);
                        console.log(`‚úÖ Driver r√©cup√©r√©: ${driverInfo.name} depuis ${branchName}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Erreur r√©cup√©ration ${file}:`, error.message);
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur r√©cup√©ration branche ${branchName}:`, error.message);
        }
    }

    async recoverFromGitHistory() {
        try {
            console.log('üì• R√©cup√©ration depuis l\'historique Git...');
            
            // Chercher les commits avec des drivers
            const commits = execSync('git log --oneline --grep="driver" --grep="Driver" -n 50', { encoding: 'utf8' });
            const commitLines = commits.split('\n').filter(line => line.trim());
            
            for (const commitLine of commitLines) {
                const commitHash = commitLine.split(' ')[0];
                try {
                    // R√©cup√©rer les fichiers drivers de ce commit
                    const files = execSync(`git show --name-only ${commitHash} | grep "drivers/"`, { encoding: 'utf8' });
                    const driverFiles = files.split('\n').filter(line => line.includes('device.js') || line.includes('driver.compose.json'));
                    
                    for (const file of driverFiles) {
                        try {
                            const content = execSync(`git show ${commitHash}:${file}`, { encoding: 'utf8' });
                            const driverInfo = this.extractDriverInfo(file, content);
                            if (driverInfo) {
                                this.recoveredDrivers.push(driverInfo);
                                console.log(`‚úÖ Driver r√©cup√©r√©: ${driverInfo.name} depuis commit ${commitHash}`);
                            }
                        } catch (error) {
                            // Ignorer les erreurs de fichiers supprim√©s
                        }
                    }
                } catch (error) {
                    // Ignorer les erreurs de commits
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration historique:', error.message);
        }
    }

    async recoverFromFusedFolders() {
        try {
            console.log('üì• R√©cup√©ration depuis les dossiers fused...');
            
            const fusedFolders = ['drivers/fused', 'drivers/recovered'];
            
            for (const folder of fusedFolders) {
                if (fs.existsSync(folder)) {
                    await this.scanFolderForDrivers(folder);
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration dossiers fused:', error.message);
        }
    }

    async scanFolderForDrivers(folderPath) {
        try {
            const items = fs.readdirSync(folderPath);
            
            for (const item of items) {
                const itemPath = path.join(folderPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    const driverFiles = fs.readdirSync(itemPath);
                    
                    if (driverFiles.includes('device.js') || driverFiles.includes('driver.compose.json')) {
                        const driverInfo = {
                            name: item,
                            path: itemPath,
                            source: 'fused',
                            files: driverFiles,
                            hasDeviceJs: driverFiles.includes('device.js'),
                            hasComposeJson: driverFiles.includes('driver.compose.json')
                        };
                        
                        // Analyser le driver.compose.json
                        const composePath = path.join(itemPath, 'driver.compose.json');
                        if (fs.existsSync(composePath)) {
                            try {
                                const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                                driverInfo.capabilities = compose.capabilities || ['onoff'];
                                driverInfo.class = compose.class || 'light';
                                driverInfo.manufacturer = compose.manufacturer || 'Generic';
                                driverInfo.model = compose.model || 'Unknown';
                            } catch (error) {
                                console.error(`‚ùå Erreur lecture compose ${composePath}:`, error.message);
                            }
                        }
                        
                        this.recoveredDrivers.push(driverInfo);
                        console.log(`‚úÖ Driver r√©cup√©r√©: ${item} depuis ${folderPath}`);
                    } else {
                        // Recherche r√©cursive
                        await this.scanFolderForDrivers(itemPath);
                    }
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur scan ${folderPath}:`, error.message);
        }
    }

    extractDriverInfo(filePath, content) {
        try {
            const fileName = path.basename(filePath);
            const dirName = path.dirname(filePath).split('/').pop();
            
            return {
                name: dirName || fileName.replace('.js', ''),
                path: filePath,
                source: 'git-history',
                content: content,
                hasDeviceJs: filePath.includes('device.js'),
                hasComposeJson: filePath.includes('driver.compose.json')
            };
        } catch (error) {
            return null;
        }
    }

    async scanCurrentDrivers() {
        console.log('üîç SCAN DES DRIVERS ACTUELS...');
        
        try {
            const driverPaths = [
                'drivers/tuya/lights',
                'drivers/tuya/switches', 
                'drivers/tuya/plugs',
                'drivers/tuya/sensors',
                'drivers/tuya/covers',
                'drivers/tuya/locks',
                'drivers/tuya/thermostats',
                'drivers/zigbee/lights',
                'drivers/zigbee/sensors',
                'drivers/zigbee/controls',
                'drivers/zigbee/covers',
                'drivers/zigbee/locks',
                'drivers/zigbee/historical'
            ];

            for (const driverPath of driverPaths) {
                if (fs.existsSync(driverPath)) {
                    await this.scanDriverDirectory(driverPath);
                }
            }

            console.log(`‚úÖ ${this.allDrivers.length} drivers actuels scann√©s`);

        } catch (error) {
            console.error('‚ùå Erreur scan drivers actuels:', error.message);
            this.results.errors.push(`Current drivers scan: ${error.message}`);
        }
    }

    async scanDriverDirectory(dirPath) {
        try {
            const items = fs.readdirSync(dirPath);
            
            for (const item of items) {
                const itemPath = path.join(dirPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    const driverFiles = fs.readdirSync(itemPath);
                    
                    if (driverFiles.includes('device.js') && driverFiles.includes('driver.compose.json')) {
                        const driverInfo = {
                            name: item,
                            path: itemPath,
                            relativePath: path.relative('.', itemPath),
                            files: driverFiles,
                            hasDeviceJs: true,
                            hasComposeJson: true,
                            source: 'current'
                        };
                        
                        // Analyser le driver.compose.json
                        const composePath = path.join(itemPath, 'driver.compose.json');
                        if (fs.existsSync(composePath)) {
                            try {
                                const compose = JSON.parse(fs.readFileSync(composePath, 'utf8'));
                                driverInfo.capabilities = compose.capabilities || ['onoff'];
                                driverInfo.class = compose.class || 'light';
                                driverInfo.manufacturer = compose.manufacturer || 'Generic';
                                driverInfo.model = compose.model || 'Unknown';
                            } catch (error) {
                                console.error(`‚ùå Erreur lecture compose ${composePath}:`, error.message);
                            }
                        }
                        
                        this.allDrivers.push(driverInfo);
                    } else {
                        // Recherche r√©cursive dans les sous-dossiers
                        await this.scanDriverDirectory(itemPath);
                    }
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur scan ${dirPath}:`, error.message);
        }
    }

    async fuseAllDrivers() {
        console.log('üîÑ FUSION DE TOUS LES DRIVERS...');
        
        try {
            // Combiner tous les drivers
            const allDrivers = [...this.allDrivers, ...this.recoveredDrivers];
            
            // √âliminer les doublons bas√©s sur le nom
            const uniqueDrivers = this.removeDuplicates(allDrivers);
            
            // Organiser par cat√©gorie
            const organizedDrivers = this.organizeDrivers(uniqueDrivers);
            
            // Cr√©er la nouvelle structure
            await this.createNewStructure(organizedDrivers);
            
            this.results.driversFused = uniqueDrivers.length;
            console.log(`‚úÖ ${uniqueDrivers.length} drivers fusionn√©s`);

        } catch (error) {
            console.error('‚ùå Erreur fusion drivers:', error.message);
            this.results.errors.push(`Driver fusion: ${error.message}`);
        }
    }

    removeDuplicates(drivers) {
        const seen = new Set();
        const unique = [];
        
        for (const driver of drivers) {
            const key = driver.name.toLowerCase();
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(driver);
            }
        }
        
        return unique;
    }

    organizeDrivers(drivers) {
        const organized = {
            tuya: {
                lights: [],
                switches: [],
                plugs: [],
                sensors: [],
                covers: [],
                locks: [],
                thermostats: []
            },
            zigbee: {
                lights: [],
                sensors: [],
                controls: [],
                covers: [],
                locks: [],
                historical: []
            }
        };
        
        for (const driver of drivers) {
            const category = this.categorizeDriver(driver);
            if (category) {
                organized[category.type][category.subtype].push(driver);
            }
        }
        
        return organized;
    }

    categorizeDriver(driver) {
        // Logique de cat√©gorisation bas√©e sur le nom et les capacit√©s
        const name = driver.name.toLowerCase();
        const capabilities = driver.capabilities || [];
        
        if (name.includes('light') || name.includes('bulb') || name.includes('rgb') || name.includes('dimmer')) {
            return { type: 'tuya', subtype: 'lights' };
        } else if (name.includes('switch') || name.includes('remote')) {
            return { type: 'tuya', subtype: 'switches' };
        } else if (name.includes('plug') || name.includes('outlet')) {
            return { type: 'tuya', subtype: 'plugs' };
        } else if (name.includes('sensor') || name.includes('motion') || name.includes('temperature')) {
            return { type: 'tuya', subtype: 'sensors' };
        } else if (name.includes('cover') || name.includes('curtain') || name.includes('blind')) {
            return { type: 'tuya', subtype: 'covers' };
        } else if (name.includes('lock')) {
            return { type: 'tuya', subtype: 'locks' };
        } else if (name.includes('thermostat')) {
            return { type: 'tuya', subtype: 'thermostats' };
        }
        
        // Par d√©faut, mettre dans tuya/lights
        return { type: 'tuya', subtype: 'lights' };
    }

    async createNewStructure(organizedDrivers) {
        console.log('üìÅ CR√âATION DE LA NOUVELLE STRUCTURE...');
        
        try {
            // Supprimer les anciens dossiers
            await this.cleanupOldStructure();
            
            // Cr√©er la nouvelle structure
            for (const [type, categories] of Object.entries(organizedDrivers)) {
                for (const [category, drivers] of Object.entries(categories)) {
                    if (drivers.length > 0) {
                        const categoryPath = `drivers/${type}/${category}`;
                        fs.mkdirSync(categoryPath, { recursive: true });
                        
                        for (const driver of drivers) {
                            await this.createDriverFolder(categoryPath, driver);
                        }
                    }
                }
            }
            
            console.log('‚úÖ Nouvelle structure cr√©√©e');

        } catch (error) {
            console.error('‚ùå Erreur cr√©ation structure:', error.message);
            this.results.errors.push(`Structure creation: ${error.message}`);
        }
    }

    async cleanupOldStructure() {
        try {
            const oldFolders = [
                'drivers/fused',
                'drivers/recovered',
                'drivers/lights',
                'drivers/switches',
                'drivers/plugs',
                'drivers/sensors',
                'drivers/covers',
                'drivers/locks',
                'drivers/thermostats'
            ];
            
            for (const folder of oldFolders) {
                if (fs.existsSync(folder)) {
                    this.removeFolderRecursively(folder);
                    console.log(`üóëÔ∏è  Ancien dossier supprim√©: ${folder}`);
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erreur nettoyage ancienne structure:', error.message);
        }
    }

    async createDriverFolder(categoryPath, driver) {
        try {
            const driverPath = path.join(categoryPath, driver.name);
            fs.mkdirSync(driverPath, { recursive: true });
            
            // Copier les fichiers du driver
            if (driver.source === 'current' && fs.existsSync(driver.path)) {
                // Copier depuis le dossier actuel
                this.copyDriverFiles(driver.path, driverPath);
            } else if (driver.content) {
                // Cr√©er les fichiers depuis le contenu r√©cup√©r√©
                this.createDriverFromContent(driverPath, driver);
            }
            
            console.log(`‚úÖ Driver cr√©√©: ${driver.name} dans ${categoryPath}`);
            
        } catch (error) {
            console.error(`‚ùå Erreur cr√©ation driver ${driver.name}:`, error.message);
        }
    }

    copyDriverFiles(sourcePath, targetPath) {
        try {
            const files = fs.readdirSync(sourcePath);
            
            for (const file of files) {
                const sourceFile = path.join(sourcePath, file);
                const targetFile = path.join(targetPath, file);
                
                if (fs.statSync(sourceFile).isFile()) {
                    fs.copyFileSync(sourceFile, targetFile);
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur copie fichiers:`, error.message);
        }
    }

    createDriverFromContent(targetPath, driver) {
        try {
            // Cr√©er device.js basique si n√©cessaire
            if (!driver.hasDeviceJs) {
                const deviceContent = this.generateBasicDeviceJs(driver);
                fs.writeFileSync(path.join(targetPath, 'device.js'), deviceContent);
            }
            
            // Cr√©er driver.compose.json basique si n√©cessaire
            if (!driver.hasComposeJson) {
                const composeContent = this.generateBasicComposeJson(driver);
                fs.writeFileSync(path.join(targetPath, 'driver.compose.json'), composeContent);
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur cr√©ation contenu driver:`, error.message);
        }
    }

    generateBasicDeviceJs(driver) {
        return `'use strict';

const { TuyaDevice } = require('homey-tuya');

class ${driver.name.charAt(0).toUpperCase() + driver.name.slice(1)}Device extends TuyaDevice {
    async onInit() {
        this.log('${driver.name} device initialized');
    }
}

module.exports = ${driver.name.charAt(0).toUpperCase() + driver.name.slice(1)}Device;
`;
    }

    generateBasicComposeJson(driver) {
        return JSON.stringify({
            "id": driver.name,
            "class": "light",
            "capabilities": ["onoff"],
            "name": {
                "en": driver.name,
                "fr": driver.name,
                "nl": driver.name
            },
            "images": {
                "small": "/assets/images/small.png",
                "large": "/assets/images/large.png"
            }
        }, null, 2);
    }

    removeFolderRecursively(folderPath) {
        if (fs.existsSync(folderPath)) {
            const items = fs.readdirSync(folderPath);
            
            for (const item of items) {
                const itemPath = path.join(folderPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    this.removeFolderRecursively(itemPath);
                } else {
                    fs.unlinkSync(itemPath);
                }
            }
            
            fs.rmdirSync(folderPath);
        }
    }

    async updateMegaStructure() {
        console.log('üîÑ MISE √Ä JOUR DE LA STRUCTURE MEGA...');
        
        try {
            // Cr√©er le dossier mega
            const megaPath = 'mega';
            fs.mkdirSync(megaPath, { recursive: true });
            
            // Cr√©er la structure mega
            const megaStructure = {
                drivers: this.allDrivers.length + this.recoveredDrivers.length,
                categories: {
                    tuya: {
                        lights: 0,
                        switches: 0,
                        plugs: 0,
                        sensors: 0,
                        covers: 0,
                        locks: 0,
                        thermostats: 0
                    },
                    zigbee: {
                        lights: 0,
                        sensors: 0,
                        controls: 0,
                        covers: 0,
                        locks: 0,
                        historical: 0
                    }
                },
                recovered: this.recoveredDrivers.length,
                fused: this.allDrivers.length,
                total: this.allDrivers.length + this.recoveredDrivers.length
            };
            
            // Compter les drivers par cat√©gorie
            for (const driver of this.allDrivers) {
                const category = this.categorizeDriver(driver);
                if (category) {
                    megaStructure.categories[category.type][category.subtype]++;
                }
            }
            
            // Sauvegarder la structure mega
            fs.writeFileSync(path.join(megaPath, 'structure.json'), JSON.stringify(megaStructure, null, 2));
            
            // Cr√©er un rapport
            const report = this.generateMegaReport(megaStructure);
            fs.writeFileSync(path.join(megaPath, 'refusion-report.md'), report);
            
            this.results.structureUpdated = 1;
            console.log('‚úÖ Structure mega mise √† jour');

        } catch (error) {
            console.error('‚ùå Erreur mise √† jour mega:', error.message);
            this.results.errors.push(`Mega update: ${error.message}`);
        }
    }

    generateMegaReport(structure) {
        return `# üîÑ MEGA DRIVER REFUSION REPORT

## üìä Statistiques
- **Total drivers**: ${structure.total}
- **Drivers actuels**: ${structure.fused}
- **Drivers r√©cup√©r√©s**: ${structure.recovered}

## üìÅ Structure par cat√©gorie

### Tuya Drivers
${Object.entries(structure.categories.tuya).map(([cat, count]) => `- **${cat}**: ${count} drivers`).join('\n')}

### Zigbee Drivers
${Object.entries(structure.categories.zigbee).map(([cat, count]) => `- **${cat}**: ${count} drivers`).join('\n')}

## üéØ R√©sultat
Refusion compl√®te r√©ussie avec ${structure.total} drivers organis√©s.
`;
    }

    async commitRefusion() {
        console.log('üíæ COMMIT DE LA REFUSION...');
        
        try {
            execSync('git add .', { stdio: 'pipe' });
            execSync('git commit -m "üîÑ MEGA DRIVER REFUSION [EN/FR/NL/TA] - Version 1.0.0 - Refusion compl√®te drivers + R√©cup√©ration anciens drivers + Nettoyage structure + Organisation par cat√©gorie + Mise √† jour mega + Optimisation projet"', { stdio: 'pipe' });
            execSync('git push origin master', { stdio: 'pipe' });
            console.log('‚úÖ Refusion commit√©e et pouss√©e');
        } catch (error) {
            console.error('‚ùå Erreur commit:', error.message);
        }
    }

    async cleanupDriverStructure() {
        console.log('üßπ NETTOYAGE DE LA STRUCTURE DRIVERS...');
        
        try {
            // Supprimer les dossiers vides restants
            const emptyFolders = [
                'drivers/zigbee/smart-life',
                'drivers/zigbee/thermostats',
                'drivers/zigbee/plugs'
            ];
            
            for (const folder of emptyFolders) {
                if (fs.existsSync(folder)) {
                    try {
                        const items = fs.readdirSync(folder);
                        if (items.length === 0) {
                            fs.rmdirSync(folder);
                            console.log(`üóëÔ∏è  Dossier vide supprim√©: ${folder}`);
                        }
                    } catch (error) {
                        console.error(`‚ùå Erreur suppression ${folder}:`, error.message);
                    }
                }
            }
            
            console.log('‚úÖ Structure drivers nettoy√©e');
            
        } catch (error) {
            console.error('‚ùå Erreur nettoyage structure drivers:', error.message);
            this.results.errors.push(`Driver structure cleanup: ${error.message}`);
        }
    }

    generateReport() {
        const duration = Date.now() - this.startTime;
        
        console.log('');
        console.log('üìä RAPPORT MEGA DRIVER REFUSION');
        console.log('==================================');
        console.log(`‚è±Ô∏è  Dur√©e: ${duration}ms`);
        console.log(`üîç Drivers r√©cup√©r√©s: ${this.results.driversRecovered}`);
        console.log(`üîÑ Drivers fusionn√©s: ${this.results.driversFused}`);
        console.log(`üì¶ Anciens drivers trouv√©s: ${this.results.oldDriversFound}`);
        console.log(`üìÅ Structure mise √† jour: ${this.results.structureUpdated}`);
        console.log(`‚ùå Erreurs: ${this.results.errors.length}`);
        
        if (this.results.errors.length > 0) {
            console.log('\nüö® Erreurs d√©tect√©es:');
            this.results.errors.forEach(error => console.log(`  - ${error}`));
        }
        
        console.log('\nüéØ MEGA DRIVER REFUSION TERMIN√â');
        console.log('‚úÖ Refusion compl√®te r√©ussie');
    }
}

// Ex√©cution
const refusion = new MegaDriverRefusion();
refusion.execute().catch(console.error); 