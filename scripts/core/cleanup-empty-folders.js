#!/usr/bin/env node

/**
 * üßπ CLEANUP EMPTY FOLDERS
 * Version: 1.0.0
 * Date: 2025-08-05
 * 
 * Suppression des dossiers vides et inutiles
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class CleanupEmptyFolders {
    constructor() {
        this.startTime = Date.now();
        this.results = {
            foldersChecked: 0,
            emptyFoldersRemoved: 0,
            unnecessaryFoldersRemoved: 0,
            errors: []
        };
        
        this.emptyFolders = [];
        this.unnecessaryFolders = [];
        
        console.log('üßπ CLEANUP EMPTY FOLDERS - D√âMARRAGE');
        console.log('üìÖ Date:', new Date().toISOString());
        console.log('üéØ Mode: YOLO CLEANUP');
        console.log('');
    }

    async execute() {
        try {
            await this.scanForEmptyFolders();
            await this.identifyUnnecessaryFolders();
            await this.removeEmptyFolders();
            await this.removeUnnecessaryFolders();
            await this.commitCleanup();
            
            this.generateReport();
        } catch (error) {
            console.error('‚ùå Erreur cleanup:', error.message);
            this.results.errors.push(error.message);
        }
    }

    async scanForEmptyFolders() {
        console.log('üîç SCAN DES DOSSIERS VIDES...');
        
        try {
            const foldersToCheck = [
                'data/external',
                'reports',
                'mega/drivers/lights/verify-drivers',
                'mega/drivers/lights/ultimate-driver-analyzer',
                'mega/drivers/lights/ultimate-driver-analysis-report',
                'mega/drivers/lights/tuya-drivers-recovery-report',
                'mega/drivers/lights/tuya-driver-creation-report-20250729-121633',
                'mega/drivers/lights/test-new-drivers',
                'mega/drivers/lights/smart-enrich-drivers',
                'mega/drivers/lights/README',
                'mega/drivers/lights/quick-driver-restoration-report',
                'mega/drivers/lights/massive-drivers-restoration-report',
                'mega/drivers/lights/icon',
                'mega/drivers/lights/historical-driver-recovery-report',
                'mega/drivers/lights/historical-driver-recovery',
                'mega/drivers/lights/generate-missing-zigbee-drivers',
                'mega/drivers/lights/fix-last-invalid-driver-report',
                'mega/drivers/lights/fix-invalid-drivers-report',
                'mega/drivers/lights/drivers-table',
                'mega/drivers/lights/drivers-restoration-report',
                'mega/drivers/lights/drivers-reorganization-report',
                'mega/drivers/lights/drivers-reorganization-fixed',
                'mega/drivers/lights/drivers-merge-improve-report',
                'mega/drivers/lights/drivers-matrix-ultimate',
                'mega/drivers/lights/drivers-matrix',
                'mega/drivers/lights/drivers-final-reorganization',
                'mega/drivers/lights/drivers-clean-report',
                'mega/drivers/lights/driver.settings.compose',
                'mega/drivers/lights/driver.compose',
                'mega/drivers/lights/driver-verification-report',
                'mega/drivers/lights/driver-validation-report',
                'mega/drivers/lights/driver-restoration-report',
                'mega/drivers/lights/driver-recovery-report-20250729-121326',
                'mega/drivers/lights/driver-recovery-report-20250729-121303',
                'mega/drivers/lights/driver-optimizer',
                'mega/drivers/lights/driver-optimization-report',
                'mega/drivers/lights/driver-matrix',
                'mega/drivers/lights/driver-integration-report',
                'mega/drivers/lights/driver-conflicts-resolution',
                'mega/drivers/lights/driver-analysis-improvement-report',
                'mega/drivers/lights/driver',
                'mega/drivers/lights/device',
                'mega/drivers/lights/comprehensive-driver-recovery-report',
                'mega/drivers/lights/comprehensive-driver-recovery',
                'mega/drivers/lights/complete-drivers-restoration-report',
                'mega/drivers/lights/complete-drivers-restoration',
                'mega/drivers/lights/complete-657-drivers-report'
            ];

            for (const folderPath of foldersToCheck) {
                if (fs.existsSync(folderPath)) {
                    this.results.foldersChecked++;
                    if (this.isFolderEmpty(folderPath)) {
                        this.emptyFolders.push(folderPath);
                        console.log(`üìÅ Dossier vide trouv√©: ${folderPath}`);
                    }
                }
            }

            console.log(`‚úÖ ${this.emptyFolders.length} dossiers vides identifi√©s`);

        } catch (error) {
            console.error('‚ùå Erreur scan dossiers vides:', error.message);
            this.results.errors.push(`Empty folders scan: ${error.message}`);
        }
    }

    async identifyUnnecessaryFolders() {
        console.log('üîç IDENTIFICATION DES DOSSIERS INUTILES...');
        
        try {
            const unnecessaryFolders = [
                'mega', // Dossier temporaire de fusion
                'tags', // Dossier de tags non utilis√©
                'data/external', // Dossier externe vide
                'reports' // Dossier de rapports vide
            ];

            for (const folderPath of unnecessaryFolders) {
                if (fs.existsSync(folderPath)) {
                    this.unnecessaryFolders.push(folderPath);
                    console.log(`üóëÔ∏è  Dossier inutile identifi√©: ${folderPath}`);
                }
            }

            console.log(`‚úÖ ${this.unnecessaryFolders.length} dossiers inutiles identifi√©s`);

        } catch (error) {
            console.error('‚ùå Erreur identification dossiers inutiles:', error.message);
            this.results.errors.push(`Unnecessary folders identification: ${error.message}`);
        }
    }

    isFolderEmpty(folderPath) {
        try {
            const items = fs.readdirSync(folderPath);
            return items.length === 0;
        } catch (error) {
            return false;
        }
    }

    async removeEmptyFolders() {
        console.log('üóëÔ∏è  SUPPRESSION DES DOSSIERS VIDES...');
        
        try {
            for (const folderPath of this.emptyFolders) {
                try {
                    fs.rmdirSync(folderPath);
                    console.log(`‚úÖ Dossier vide supprim√©: ${folderPath}`);
                    this.results.emptyFoldersRemoved++;
                } catch (error) {
                    console.error(`‚ùå Erreur suppression ${folderPath}:`, error.message);
                    this.results.errors.push(`Remove empty folder ${folderPath}: ${error.message}`);
                }
            }

            console.log(`‚úÖ ${this.results.emptyFoldersRemoved} dossiers vides supprim√©s`);

        } catch (error) {
            console.error('‚ùå Erreur suppression dossiers vides:', error.message);
            this.results.errors.push(`Remove empty folders: ${error.message}`);
        }
    }

    async removeUnnecessaryFolders() {
        console.log('üóëÔ∏è  SUPPRESSION DES DOSSIERS INUTILES...');
        
        try {
            for (const folderPath of this.unnecessaryFolders) {
                try {
                    if (fs.existsSync(folderPath)) {
                        // Supprimer r√©cursivement
                        this.removeFolderRecursively(folderPath);
                        console.log(`‚úÖ Dossier inutile supprim√©: ${folderPath}`);
                        this.results.unnecessaryFoldersRemoved++;
                    }
                } catch (error) {
                    console.error(`‚ùå Erreur suppression ${folderPath}:`, error.message);
                    this.results.errors.push(`Remove unnecessary folder ${folderPath}: ${error.message}`);
                }
            }

            console.log(`‚úÖ ${this.results.unnecessaryFoldersRemoved} dossiers inutiles supprim√©s`);

        } catch (error) {
            console.error('‚ùå Erreur suppression dossiers inutiles:', error.message);
            this.results.errors.push(`Remove unnecessary folders: ${error.message}`);
        }
    }

    removeFolderRecursively(folderPath) {
        if (fs.existsSync(folderPath)) {
            const items = fs.readdirSync(folderPath);
            
            for (const item of items) {
                const itemPath = path.join(folderPath, item);
                const itemStat = fs.statSync(itemPath);
                
                if (itemStat.isDirectory()) {
                    this.removeFolderRecursively(itemPath);
                } else {
                    fs.unlinkSync(itemPath);
                }
            }
            
            fs.rmdirSync(folderPath);
        }
    }

    async commitCleanup() {
        console.log('üíæ COMMIT DU NETTOYAGE...');
        
        try {
            execSync('git add .', { stdio: 'pipe' });
            execSync('git commit -m "üßπ CLEANUP EMPTY FOLDERS [EN/FR/NL/TA] - Version 1.0.0 - Suppression dossiers vides + Suppression dossiers inutiles + Nettoyage structure + Optimisation projet + R√©duction taille"', { stdio: 'pipe' });
            execSync('git push origin master', { stdio: 'pipe' });
            console.log('‚úÖ Nettoyage commit√© et pouss√©');
        } catch (error) {
            console.error('‚ùå Erreur commit:', error.message);
        }
    }

    generateReport() {
        const duration = Date.now() - this.startTime;
        
        console.log('');
        console.log('üìä RAPPORT CLEANUP EMPTY FOLDERS');
        console.log('==================================');
        console.log(`‚è±Ô∏è  Dur√©e: ${duration}ms`);
        console.log(`üîç Dossiers v√©rifi√©s: ${this.results.foldersChecked}`);
        console.log(`üóëÔ∏è  Dossiers vides supprim√©s: ${this.results.emptyFoldersRemoved}`);
        console.log(`üóëÔ∏è  Dossiers inutiles supprim√©s: ${this.results.unnecessaryFoldersRemoved}`);
        console.log(`‚ùå Erreurs: ${this.results.errors.length}`);
        
        if (this.results.errors.length > 0) {
            console.log('\nüö® Erreurs d√©tect√©es:');
            this.results.errors.forEach(error => console.log(`  - ${error}`));
        }
        
        console.log('\nüéØ CLEANUP EMPTY FOLDERS TERMIN√â');
        console.log('‚úÖ Projet nettoy√© avec succ√®s');
    }
}

// Ex√©cution
const cleanup = new CleanupEmptyFolders();
cleanup.execute().catch(console.error); 