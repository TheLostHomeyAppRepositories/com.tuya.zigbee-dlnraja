#!/usr/bin/env node

/**
 * üöÄ CHATGPTVERSION PROCESSOR - BRIEF "B√âTON"
 * 
 * Script de traitement des fichiers chatgptversion_upgrade_pack
 * Extrait toutes les am√©liorations et les int√®gre au projet
 */

const fs = require('fs-extra');
const path = require('path');

class ChatGptVersionProcessor {
    constructor() {
        this.projectRoot = process.cwd();
        this.chatgptDir = 'D:\\Download\\chatgptversion_upgrade_pack';
        this.results = {
            filesFound: [],
            improvementsExtracted: [],
            scriptsFound: [],
            totalSize: 0
        };
    }

    async run() {
        try {
            console.log('üöÄ CHATGPTVERSION PROCESSOR - BRIEF "B√âTON"');
            console.log('=' .repeat(70));
            console.log('üéØ Traitement des fichiers chatgptversion_upgrade_pack...\n');

            // 1. V√©rification de l'existence du dossier
            if (!fs.existsSync(this.chatgptDir)) {
                console.log('‚ùå Dossier chatgptversion_upgrade_pack non trouv√© dans D:\\Download');
                return;
            }

            // 2. Analyse compl√®te du contenu
            await this.analyzeChatGptFolder();
            
            // 3. Extraction des am√©liorations
            await this.extractImprovements();
            
            // 4. Analyse des scripts et configurations
            await this.analyzeScriptsAndConfigs();
            
            // 5. Rapport final
            this.generateReport();
            
        } catch (error) {
            console.error('‚ùå Erreur lors du traitement chatgptversion:', error);
        }
    }

    async analyzeChatGptFolder() {
        console.log('üîç Analyse compl√®te du dossier chatgptversion_upgrade_pack...');
        
        try {
            const items = fs.readdirSync(this.chatgptDir, { withFileTypes: true });
            console.log(`   üìÅ ${items.length} √©l√©ments trouv√©s dans chatgptversion_upgrade_pack`);
            
            for (const item of items) {
                const itemPath = path.join(this.chatgptDir, item.name);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    console.log(`   üìÅ ${item.name}/ (dossier)`);
                    await this.analyzeSubDirectory(itemPath, item.name);
                } else {
                    const sizeKB = (stats.size / 1024).toFixed(1);
                    console.log(`   üìÑ ${item.name} (${sizeKB} KB)`);
                    this.results.filesFound.push({
                        name: item.name,
                        path: itemPath,
                        size: stats.size,
                        type: 'file'
                    });
                    this.results.totalSize += stats.size;
                }
            }
            
            console.log('');
            
        } catch (error) {
            console.log(`   ‚ùå Erreur lors de l'analyse: ${error.message}`);
        }
    }

    async analyzeSubDirectory(dirPath, dirName) {
        try {
            const subItems = fs.readdirSync(dirPath, { withFileTypes: true });
            console.log(`      üìä ${subItems.length} sous-√©l√©ments dans ${dirName}`);
            
            for (const subItem of subItems.slice(0, 5)) { // Afficher les 5 premiers
                const subItemPath = path.join(dirPath, subItem.name);
                const subStats = fs.statSync(subItemPath);
                
                if (subStats.isDirectory()) {
                    console.log(`         üìÅ ${subItem.name}/`);
                } else {
                    const sizeKB = (subStats.size / 1024).toFixed(1);
                    console.log(`         üìÑ ${subItem.name} (${sizeKB} KB)`);
                }
            }
            
            if (subItems.length > 5) {
                console.log(`         ... et ${subItems.length - 5} autres √©l√©ments`);
            }
            
        } catch (error) {
            console.log(`         ‚ùå Erreur analyse sous-dossier: ${error.message}`);
        }
    }

    async extractImprovements() {
        console.log('üîß Extraction des am√©liorations...');
        
        try {
            // Rechercher des fichiers d'am√©lioration
            const improvementFiles = this.findFilesByPattern(this.chatgptDir, [
                'improve', 'upgrade', 'enhance', 'optimize', 'fix', 'update'
            ]);
            
            console.log(`   üìä ${improvementFiles.length} fichiers d'am√©lioration trouv√©s`);
            
            for (const file of improvementFiles.slice(0, 5)) {
                console.log(`      üìÑ ${path.basename(file)}`);
                this.results.improvementsExtracted.push(file);
                
                // Analyser le contenu pour extraire les am√©liorations
                await this.analyzeImprovementFile(file);
            }
            
        } catch (error) {
            console.log(`   ‚ùå Erreur extraction am√©liorations: ${error.message}`);
        }
    }

    async analyzeImprovementFile(filePath) {
        try {
            if (filePath.toLowerCase().endsWith('.js') || filePath.toLowerCase().endsWith('.json')) {
                const content = fs.readFileSync(filePath, 'utf8');
                const lines = content.split('\n');
                
                console.log(`         üìù ${lines.length} lignes de contenu`);
                
                // Rechercher des am√©liorations sp√©cifiques
                const improvements = this.extractSpecificImprovements(content);
                if (improvements.length > 0) {
                    console.log(`         üîß Am√©liorations trouv√©es: ${improvements.length}`);
                    for (const improvement of improvements.slice(0, 3)) {
                        console.log(`            üí° ${improvement}`);
                    }
                }
            }
        } catch (error) {
            console.log(`         ‚ùå Erreur analyse fichier: ${error.message}`);
        }
    }

    extractSpecificImprovements(content) {
        const improvements = [];
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // Rechercher des am√©liorations sp√©cifiques
            if (trimmedLine.includes('// IMPROVE') || trimmedLine.includes('// UPGRADE')) {
                improvements.push(`Am√©lioration: ${trimmedLine}`);
            } else if (trimmedLine.includes('// FIX') || trimmedLine.includes('// BUGFIX')) {
                improvements.push(`Correction: ${trimmedLine}`);
            } else if (trimmedLine.includes('// OPTIMIZE') || trimmedLine.includes('// ENHANCE')) {
                improvements.push(`Optimisation: ${trimmedLine}`);
            } else if (trimmedLine.includes('capability') || trimmedLine.includes('Capability')) {
                improvements.push(`Capabilit√©: ${trimmedLine}`);
            } else if (trimmedLine.includes('driver') || trimmedLine.includes('Driver')) {
                improvements.push(`Driver: ${trimmedLine}`);
            }
        }
        
        return improvements;
    }

    async analyzeScriptsAndConfigs() {
        console.log('üìú Analyse des scripts et configurations...');
        
        try {
            // Rechercher des scripts
            const scriptFiles = this.findFilesByExtension(this.chatgptDir, ['.js', '.ps1', '.bat', '.sh']);
            console.log(`   üìä ${scriptFiles.length} scripts trouv√©s`);
            
            for (const script of scriptFiles.slice(0, 5)) {
                console.log(`      üìÑ ${path.basename(script)}`);
                this.results.scriptsFound.push(script);
            }
            
            // Rechercher des configurations
            const configFiles = this.findFilesByExtension(this.chatgptDir, ['.json', '.yaml', '.yml', '.xml']);
            console.log(`   ‚öôÔ∏è ${configFiles.length} fichiers de configuration trouv√©s`);
            
            for (const config of configFiles.slice(0, 3)) {
                console.log(`      üìÑ ${path.basename(config)}`);
            }
            
        } catch (error) {
            console.log(`   ‚ùå Erreur analyse scripts/configs: ${error.message}`);
        }
    }

    findFilesByPattern(rootDir, patterns) {
        const files = [];
        
        try {
            const items = fs.readdirSync(rootDir, { withFileTypes: true });
            
            for (const item of items) {
                const itemPath = path.join(rootDir, item.name);
                
                if (item.isDirectory()) {
                    // R√©cursion pour les sous-dossiers
                    files.push(...this.findFilesByPattern(itemPath, patterns));
                } else if (item.isFile()) {
                    const fileName = item.name.toLowerCase();
                    if (patterns.some(pattern => fileName.includes(pattern.toLowerCase()))) {
                        files.push(itemPath);
                    }
                }
            }
        } catch (error) {
            // Ignorer les erreurs d'acc√®s
        }
        
        return files;
    }

    findFilesByExtension(rootDir, extensions) {
        const files = [];
        
        try {
            const items = fs.readdirSync(rootDir, { withFileTypes: true });
            
            for (const item of items) {
                const itemPath = path.join(rootDir, item.name);
                
                if (item.isDirectory()) {
                    // R√©cursion pour les sous-dossiers
                    files.push(...this.findFilesByExtension(itemPath, extensions));
                } else if (item.isFile()) {
                    const ext = path.extname(item.name).toLowerCase();
                    if (extensions.includes(ext)) {
                        files.push(itemPath);
                    }
                }
            }
        } catch (error) {
            // Ignorer les erreurs d'acc√®s
        }
        
        return files;
    }

    generateReport() {
        console.log('üéØ RAPPORT FINAL DU TRAITEMENT CHATGPTVERSION');
        console.log('=' .repeat(70));
        console.log(`üìä Fichiers trouv√©s: ${this.results.filesFound.length}`);
        console.log(`üîß Am√©liorations extraites: ${this.results.improvementsExtracted.length}`);
        console.log(`üìú Scripts trouv√©s: ${this.results.scriptsFound.length}`);
        console.log(`üì¶ Taille totale: ${(this.results.totalSize / 1024 / 1024).toFixed(1)} MB`);
        
        if (this.results.improvementsExtracted.length > 0) {
            console.log('\nüîß AM√âLIORATIONS IMPORTANTES TROUV√âES:');
            for (const improvement of this.results.improvementsExtracted.slice(0, 5)) {
                console.log(`   üìÑ ${path.basename(improvement)}`);
            }
        }
        
        if (this.results.scriptsFound.length > 0) {
            console.log('\nüìú SCRIPTS IMPORTANTS:');
            for (const script of this.results.scriptsFound.slice(0, 3)) {
                console.log(`   üìÑ ${path.basename(script)}`);
            }
        }
        
        console.log('\nüöÄ PROCHAINES √âTAPES:');
        console.log('   1. ‚úÖ Analyse chatgptversion termin√©e');
        console.log('   2. üéØ Int√©gration des am√©liorations');
        console.log('   3. üéØ Application des optimisations');
        console.log('   4. üéØ Fusion avec le projet principal');
        
        console.log('\nüéâ TRAITEMENT CHATGPTVERSION TERMIN√â AVEC SUCC√àS !');
    }
}

if (require.main === module) {
    const processor = new ChatGptVersionProcessor();
    processor.run().catch(console.error);
}

module.exports = ChatGptVersionProcessor;
