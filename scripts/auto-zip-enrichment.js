#!/usr/bin/env node

/**
 * üöÄ AUTO ZIP ENRICHMENT - BRIEF "B√âTON"
 * 
 * Script automatique qui lance l'extraction ZIP en arri√®re-plan
 * et continue l'enrichissement du projet sans interruption
 */

const BackgroundZipProcessor = require('./background-zip-processor');
const DownloadAnalyzerEnricher = require('./download-analyzer-enricher');
const fs = require('fs-extra');
const path = require('path');

class AutoZipEnrichment {
    constructor() {
        this.projectRoot = process.cwd();
        this.zipProcessor = null;
        this.enricher = null;
        this.isRunning = false;
        this.enrichmentInterval = null;
    }

    async run() {
        try {
            console.log('üöÄ AUTO ZIP ENRICHMENT - BRIEF "B√âTON"');
            console.log('=' .repeat(70));
            console.log('üéØ Lancement automatique de l\'extraction et enrichissement...\n');

            // 1. Lancer l'extraction ZIP en arri√®re-plan
            await this.startZipExtraction();

            // 2. Continuer l'enrichissement du projet
            await this.continueProjectEnrichment();

            // 3. Monitoring automatique
            this.startAutomaticMonitoring();

            console.log('‚úÖ Processus automatique lanc√© avec succ√®s !');
            console.log('üìä L\'extraction ZIP se fait en arri√®re-plan');
            console.log('üîß L\'enrichissement du projet continue...\n');

        } catch (error) {
            console.error('‚ùå Erreur lors du lancement automatique:', error);
        }
    }

    async startZipExtraction() {
        console.log('üì¶ LANCEMENT DE L\'EXTRACTION ZIP EN ARRI√àRE-PLAN');
        console.log('-' .repeat(50));

        try {
            // Cr√©er et lancer le processeur ZIP
            this.zipProcessor = new BackgroundZipProcessor();
            
            // Lancer l'extraction en arri√®re-plan
            this.zipProcessor.run().catch(error => {
                console.log(`   ‚ö†Ô∏è Erreur extraction ZIP: ${error.message}`);
            });

            console.log('   ‚úÖ Processus d\'extraction ZIP lanc√© en arri√®re-plan');
            console.log('   üìä Monitoring automatique activ√©');

        } catch (error) {
            console.log(`   ‚ùå Erreur lors du lancement ZIP: ${error.message}`);
        }
    }

    async continueProjectEnrichment() {
        console.log('üîß CONTINUATION DE L\'ENRICHISSEMENT DU PROJET');
        console.log('-' .repeat(50));

        try {
            // Cr√©er l'enricheur
            this.enricher = new DownloadAnalyzerEnrichment();
            
            // Lancer l'enrichissement
            this.enricher.run().catch(error => {
                console.log(`   ‚ö†Ô∏è Erreur enrichissement: ${error.message}`);
            });

            console.log('   ‚úÖ Enrichissement du projet lanc√©');
            console.log('   üìä Analyse et am√©lioration en cours');

        } catch (error) {
            console.log(`   ‚ùå Erreur lors de l\'enrichissement: ${error.message}`);
        }
    }

    startAutomaticMonitoring() {
        console.log('üìä D√âMARRAGE DU MONITORING AUTOMATIQUE');
        console.log('-' .repeat(50));

        // Monitoring toutes les 30 secondes
        this.enrichmentInterval = setInterval(async () => {
            await this.performAutomaticEnrichment();
        }, 30000);

        console.log('   ‚úÖ Monitoring automatique d√©marr√© (30s)');
        console.log('   üîÑ Enrichissement automatique activ√©');
    }

    async performAutomaticEnrichment() {
        try {
            console.log('\nüîÑ ENRICHISSEMENT AUTOMATIQUE EN COURS...');
            
            // V√©rifier le statut des extractions
            await this.checkZipExtractionStatus();
            
            // V√©rifier les nouveaux fichiers extraits
            await this.checkNewExtractedFiles();
            
            // Appliquer des am√©liorations automatiques
            await this.applyAutomaticImprovements();

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur enrichissement automatique: ${error.message}`);
        }
    }

    async checkZipExtractionStatus() {
        try {
            const statusFile = path.join(this.projectRoot, '.tmp_background_zip', 'extraction-status.json');
            
            if (fs.existsSync(statusFile)) {
                const status = JSON.parse(fs.readFileSync(statusFile, 'utf8'));
                
                const progress = status.stats.totalZips > 0 ? 
                    ((status.stats.extracted + status.stats.failed) / status.stats.totalZips * 100).toFixed(1) : 0;

                console.log(`   üìä ZIPs: ${progress}% (${status.stats.extracted}/${status.stats.totalZips})`);
                
                // Si des extractions sont termin√©es, d√©clencher l'analyse
                if (status.stats.extracted > 0) {
                    await this.analyzeNewlyExtractedFiles();
                }
            }

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur v√©rification statut: ${error.message}`);
        }
    }

    async checkNewExtractedFiles() {
        try {
            const tmpDir = path.join(this.projectRoot, '.tmp_background_zip');
            
            if (!fs.existsSync(tmpDir)) {
                return;
            }

            const extractedDirs = fs.readdirSync(tmpDir, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);

            for (const dir of extractedDirs) {
                const dirPath = path.join(tmpDir, dir);
                await this.analyzeExtractedDirectory(dir, dirPath);
            }

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur v√©rification nouveaux fichiers: ${error.message}`);
        }
    }

    async analyzeExtractedDirectory(dirName, dirPath) {
        try {
            // V√©rifier si le dossier contient des √©l√©ments utiles
            const items = fs.readdirSync(dirPath);
            
            if (items.length === 0) {
                return;
            }

            // Analyser le contenu pour l'enrichissement
            await this.analyzeContentForEnrichment(dirName, dirPath, items);

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur analyse dossier ${dirName}: ${error.message}`);
        }
    }

    async analyzeContentForEnrichment(dirName, dirPath, items) {
        try {
            let hasDrivers = false;
            let hasScripts = false;
            let hasAssets = false;
            let hasCatalog = false;

            for (const item of items) {
                const itemPath = path.join(dirPath, item);
                const itemStats = fs.statSync(itemPath);

                if (itemStats.isDirectory()) {
                    if (item === 'drivers') {
                        hasDrivers = true;
                        await this.analyzeDriversForEnrichment(itemPath);
                    } else if (item === 'scripts') {
                        hasScripts = true;
                        await this.analyzeScriptsForEnrichment(itemPath);
                    } else if (item === 'assets') {
                        hasAssets = true;
                        await this.analyzeAssetsForEnrichment(itemPath);
                    } else if (item === 'catalog') {
                        hasCatalog = true;
                        await this.analyzeCatalogForEnrichment(itemPath);
                    }
                }
            }

            // Cr√©er un rapport d'analyse
            await this.createExtractionAnalysisReport(dirName, {
                hasDrivers,
                hasScripts,
                hasAssets,
                hasCatalog,
                totalItems: items.length
            });

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur analyse enrichissement: ${error.message}`);
        }
    }

    async analyzeDriversForEnrichment(driversPath) {
        try {
            const categories = fs.readdirSync(driversPath, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);

            console.log(`      üîß Drivers trouv√©s: ${categories.length} cat√©gories`);

            // Analyser quelques drivers pour l'enrichissement
            for (const category of categories.slice(0, 2)) {
                const categoryPath = path.join(driversPath, category);
                await this.analyzeDriverCategory(category, categoryPath);
            }

        } catch (error) {
            console.log(`      ‚ö†Ô∏è Erreur analyse drivers: ${error.message}`);
        }
    }

    async analyzeDriverCategory(categoryName, categoryPath) {
        try {
            const drivers = fs.readdirSync(categoryPath, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);

            console.log(`         üìÅ ${categoryName}: ${drivers.length} drivers`);

            // Analyser un driver exemple
            if (drivers.length > 0) {
                const sampleDriver = drivers[0];
                const sampleDriverPath = path.join(categoryPath, sampleDriver);
                await this.analyzeSampleDriverForEnrichment(sampleDriver, sampleDriverPath);
            }

        } catch (error) {
            console.log(`         ‚ö†Ô∏è Erreur analyse cat√©gorie: ${error.message}`);
        }
    }

    async analyzeSampleDriverForEnrichment(driverName, driverPath) {
        try {
            const driverFiles = fs.readdirSync(driverPath);
            
            // V√©rifier les fichiers du driver
            const hasDevice = driverFiles.includes('device.js');
            const hasDriver = driverFiles.includes('driver.js');
            const hasCompose = driverFiles.includes('driver.compose.json');
            const hasMetadata = driverFiles.includes('metadata.json');

            if (hasDevice && hasDriver && hasCompose) {
                console.log(`            ‚úÖ ${driverName}: Structure compl√®te`);
            } else {
                console.log(`            ‚ö†Ô∏è ${driverName}: Structure incompl√®te`);
            }

        } catch (error) {
            console.log(`            ‚ö†Ô∏è Erreur analyse driver: ${error.message}`);
        }
    }

    async analyzeScriptsForEnrichment(scriptsPath) {
        try {
            const scripts = fs.readdirSync(scriptsPath, { withFileTypes: true })
                .filter(dirent => dirent.isFile() && dirent.name.endsWith('.js'))
                .map(dirent => dirent.name);

            console.log(`      üìú Scripts trouv√©s: ${scripts.length} fichiers`);

        } catch (error) {
            console.log(`      ‚ö†Ô∏è Erreur analyse scripts: ${error.message}`);
        }
    }

    async analyzeAssetsForEnrichment(assetsPath) {
        try {
            const assets = fs.readdirSync(assetsPath, { withFileTypes: true })
                .filter(dirent => dirent.isFile())
                .map(dirent => dirent.name);

            console.log(`      üñºÔ∏è Assets trouv√©s: ${assets.length} fichiers`);

        } catch (error) {
            console.log(`      ‚ö†Ô∏è Erreur analyse assets: ${error.message}`);
        }
    }

    async analyzeCatalogForEnrichment(catalogPath) {
        try {
            const catalogItems = fs.readdirSync(catalogPath, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);

            console.log(`      üìö Catalog trouv√©: ${catalogItems.length} cat√©gories`);

        } catch (error) {
            console.log(`      ‚ö†Ô∏è Erreur analyse catalog: ${error.message}`);
        }
    }

    async createExtractionAnalysisReport(dirName, analysis) {
        try {
            const reportPath = path.join(this.projectRoot, '.tmp_background_zip', `${dirName}_analysis.json`);
            
            const report = {
                extractedAt: new Date().toISOString(),
                directory: dirName,
                analysis: analysis,
                recommendations: this.generateRecommendations(analysis)
            };

            fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
            console.log(`      üìù Rapport d'analyse cr√©√©: ${dirName}`);

        } catch (error) {
            console.log(`      ‚ö†Ô∏è Erreur cr√©ation rapport: ${error.message}`);
        }
    }

    generateRecommendations(analysis) {
        const recommendations = [];

        if (analysis.hasDrivers) {
            recommendations.push('Analyser et int√©grer les drivers d√©couverts');
        }
        if (analysis.hasScripts) {
            recommendations.push('√âtudier les scripts pour les bonnes pratiques');
        }
        if (analysis.hasAssets) {
            recommendations.push('V√©rifier et int√©grer les assets utiles');
        }
        if (analysis.hasCatalog) {
            recommendations.push('Analyser la structure catalog pour l\'organisation');
        }

        return recommendations;
    }

    async applyAutomaticImprovements() {
        try {
            console.log('   üîß Application d\'am√©liorations automatiques...');

            // V√©rifier et am√©liorer la structure du projet
            await this.improveProjectStructure();
            
            // V√©rifier et am√©liorer les drivers
            await this.improveDrivers();
            
            // V√©rifier et am√©liorer les assets
            await this.improveAssets();

        } catch (error) {
            console.log(`   ‚ö†Ô∏è Erreur am√©liorations automatiques: ${error.message}`);
        }
    }

    async improveProjectStructure() {
        try {
            // Cr√©er la structure catalog si elle n'existe pas
            const catalogPath = path.join(this.projectRoot, 'catalog');
            if (!fs.existsSync(catalogPath)) {
                fs.mkdirSync(catalogPath, { recursive: true });
                console.log('         üìÅ Structure catalog/ cr√©√©e automatiquement');
            }

        } catch (error) {
            console.log(`         ‚ö†Ô∏è Erreur am√©lioration structure: ${error.message}`);
        }
    }

    async improveDrivers() {
        try {
            // V√©rifier et am√©liorer les drivers existants
            const driversPath = path.join(this.projectRoot, 'drivers');
            
            if (fs.existsSync(driversPath)) {
                // Logique d'am√©lioration automatique des drivers
                console.log('         üîß Am√©lioration automatique des drivers...');
            }

        } catch (error) {
            console.log(`         ‚ö†Ô∏è Erreur am√©lioration drivers: ${error.message}`);
        }
    }

    async improveAssets() {
        try {
            // V√©rifier et am√©liorer les assets
            const assetsPath = path.join(this.projectRoot, 'assets');
            
            if (fs.existsSync(assetsPath)) {
                // Logique d'am√©lioration automatique des assets
                console.log('         üñºÔ∏è Am√©lioration automatique des assets...');
            }

        } catch (error) {
            console.log(`         ‚ö†Ô∏è Erreur am√©lioration assets: ${error.message}`);
        }
    }

    async analyzeNewlyExtractedFiles() {
        console.log('   üîç Analyse des nouveaux fichiers extraits...');
        
        // Cette m√©thode sera appel√©e quand de nouveaux fichiers sont extraits
        // pour d√©clencher l'analyse et l'enrichissement
    }

    // M√©thode pour arr√™ter le processus automatique
    stop() {
        console.log('\nüõë Arr√™t du processus automatique...');

        if (this.enrichmentInterval) {
            clearInterval(this.enrichmentInterval);
            this.enrichmentInterval = null;
        }

        if (this.zipProcessor) {
            this.zipProcessor.stopAllProcesses();
        }

        this.isRunning = false;
        console.log('‚úÖ Processus automatique arr√™t√©');
    }

    // M√©thode pour obtenir le statut
    getStatus() {
        return {
            isRunning: this.isRunning,
            zipProcessor: this.zipProcessor ? this.zipProcessor.getStatus() : null,
            enrichmentInterval: this.enrichmentInterval ? 'active' : 'inactive'
        };
    }
}

// Gestion des signaux pour un arr√™t propre
process.on('SIGINT', () => {
    console.log('\nüõë Signal SIGINT re√ßu, arr√™t propre...');
    if (global.autoEnrichment) {
        global.autoEnrichment.stop();
    }
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Signal SIGTERM re√ßu, arr√™t propre...');
    if (global.autoEnrichment) {
        global.autoEnrichment.stop();
    }
    process.exit(0);
});

if (require.main === module) {
    const autoEnrichment = new AutoZipEnrichment();
    global.autoEnrichment = autoEnrichment;
    autoEnrichment.run().catch(console.error);
}

module.exports = AutoZipEnrichment;
