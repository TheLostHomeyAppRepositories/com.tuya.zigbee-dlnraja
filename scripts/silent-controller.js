#!/usr/bin/env node
'use strict';

#!/usr/bin/env node

/**
 * üéÆ SILENT CONTROLLER - BRIEF "B√âTON"
 * 
 * Contr√¥leur silencieux pour le processus d'extraction et d'enrichissement
 * Permet de d√©marrer, arr√™ter et surveiller sans affichage
 */

const SilentBackgroundProcessor = require('./silent-background-processor');
const fs = require('fs-extra');
const path = require('path');

class SilentController {
    constructor() {
        this.processor = null;
        this.isRunning = false;
        this.statusFile = path.join(process.cwd(), '.tmp_silent_processing', 'silent-status.json');
    }

    async run() {
        try {
            console.log('üéÆ SILENT CONTROLLER - BRIEF "B√âTON"');
            console.log('=' .repeat(70));
            console.log('üéØ Contr√¥leur du processus silencieux...\n');

            // Afficher le menu principal
            await this.showMainMenu();

        } catch (error) {
            console.error('‚ùå Erreur dans le contr√¥leur:', error);
        }
    }

    async showMainMenu() {
        while (true) {
            console.log('\nüéÆ MENU PRINCIPAL - SILENT PROCESSOR');
            console.log('=' .repeat(50));
            console.log('1. üöÄ D√©marrer le processus silencieux');
            console.log('2. üìä V√©rifier le statut');
            console.log('3. üìã Afficher les logs');
            console.log('4. üõë Arr√™ter tous les processus');
            console.log('5. üîÑ Red√©marrer le processus');
            console.log('6. üìÅ Ouvrir le dossier de travail');
            console.log('7. üßπ Nettoyer les fichiers temporaires');
            console.log('8. ‚ùå Quitter');
            console.log('');

            const choice = await this.getUserChoice('Choisissez une option (1-8): ');

            switch (choice) {
                case '1':
                    await this.startSilentProcess();
                    break;
                case '2':
                    await this.checkStatus();
                    break;
                case '3':
                    await this.showLogs();
                    break;
                case '4':
                    await this.stopAllProcesses();
                    break;
                case '5':
                    await this.restartProcess();
                    break;
                case '6':
                    await this.openWorkFolder();
                    break;
                case '7':
                    await this.cleanupTempFiles();
                    break;
                case '8':
                    console.log('üëã Au revoir !');
                    process.exit(0);
                    break;
                default:
                    console.log('‚ùå Option invalide, veuillez r√©essayer.');
            }

            // Pause avant de revenir au menu
            await this.sleep(2000);
        }
    }

    async startSilentProcess() {
        console.log('\nüöÄ D√âMARRAGE DU PROCESSUS SILENCIEUX');
        console.log('-' .repeat(50));

        if (this.isRunning) {
            console.log('   ‚ö†Ô∏è Le processus est d√©j√† en cours');
            return;
        }

        try {
            // D√©marrer le processus silencieux
            this.processor = new SilentBackgroundProcessor();
            this.isRunning = true;

            // Lancer le processus dans un processus s√©par√©
            this.processor.run().catch(error => {
                console.log(`   ‚ùå Erreur lors du d√©marrage: ${error.message}`);
                this.isRunning = false;
            });

            console.log('   ‚úÖ Processus silencieux d√©marr√© en arri√®re-plan');
            console.log('   üìä Utilisez l\'option 2 pour v√©rifier le statut');
            console.log('   üîá Aucun affichage dans le terminal principal');

        } catch (error) {
            console.log(`   ‚ùå Erreur lors du d√©marrage: ${error.message}`);
            this.isRunning = false;
        }
    }

    async checkStatus() {
        console.log('\nüìä V√âRIFICATION DU STATUT');
        console.log('-' .repeat(50));

        try {
            if (fs.existsSync(this.statusFile)) {
                const status = JSON.parse(fs.readFileSync(this.statusFile, 'utf8'));
                
                console.log(`   üïê Derni√®re mise √† jour: ${status.lastUpdate}`);
                console.log(`   üìä Total ZIPs: ${status.stats.totalZips}`);
                console.log(`   ‚úÖ Extrait: ${status.stats.extracted}`);
                console.log(`   ‚ùå √âchou√©: ${status.stats.failed}`);
                console.log(`   üîÑ En cours: ${status.stats.inProgress}`);
                console.log(`   üîß √âtapes d'enrichissement: ${status.stats.enrichmentSteps}`);

                if (status.stats.totalZips > 0) {
                    const progress = ((status.stats.extracted + status.stats.failed) / status.stats.totalZips * 100).toFixed(1);
                    console.log(`   üìà Progression: ${progress}%`);
                }

                if (status.processes.length > 0) {
                    console.log('\n   üìã D√©tail des processus:');
                    for (const process of status.processes) {
                        const duration = process.duration || 0;
                        const statusIcon = process.status === 'completed' ? '‚úÖ' : 
                                          process.status === 'running' ? 'üîÑ' : 
                                          process.status === 'failed' ? '‚ùå' : '‚è∏Ô∏è';
                        console.log(`      ${statusIcon} ${process.name}: ${process.status} (${duration}s)`);
                    }
                }

            } else {
                console.log('   ‚ö†Ô∏è Aucun fichier de statut trouv√©');
                console.log('   üöÄ D√©marrez d\'abord le processus (option 1)');
            }

        } catch (error) {
            console.log(`   ‚ùå Erreur lors de la v√©rification: ${error.message}`);
        }
    }

    async showLogs() {
        console.log('\nüìã AFFICHAGE DES LOGS');
        console.log('-' .repeat(50));

        const logs = SilentBackgroundProcessor.getLogs();
        
        if (logs) {
            const lines = logs.split('\n');
            console.log(`   üìÑ Total lignes: ${lines.length}`);
            
            // Afficher les 30 derni√®res lignes
            const recentLines = lines.slice(-30);
            console.log('\n   üìã 30 derni√®res lignes:');
            console.log('   ' + '=' .repeat(40));
            
            for (const line of recentLines) {
                if (line.trim()) {
                    console.log(`   ${line}`);
                }
            }

        } else {
            console.log('   ‚ö†Ô∏è Aucun log trouv√©');
            console.log('   üöÄ D√©marrez d\'abord le processus (option 1)');
        }
    }

    async stopAllProcesses() {
        console.log('\nüõë ARR√äT DE TOUS LES PROCESSUS');
        console.log('-' .repeat(50));

        if (this.processor && this.isRunning) {
            try {
                this.processor.stopAllProcesses();
                this.isRunning = false;
                console.log('   ‚úÖ Tous les processus arr√™t√©s');
            } catch (error) {
                console.log(`   ‚ùå Erreur lors de l\'arr√™t: ${error.message}`);
            }
        } else {
            console.log('   ‚ö†Ô∏è Aucun processus en cours');
        }
    }

    async restartProcess() {
        console.log('\nüîÑ RED√âMARRAGE DU PROCESSUS');
        console.log('-' .repeat(50));

        try {
            // Arr√™ter le processus actuel
            if (this.processor && this.isRunning) {
                this.processor.stopAllProcesses();
                this.isRunning = false;
                console.log('   ‚úÖ Processus actuel arr√™t√©');
            }

            // Attendre un peu
            await this.sleep(3000);

            // Red√©marrer
            await this.startSilentProcess();

        } catch (error) {
            console.log(`   ‚ùå Erreur lors du red√©marrage: ${error.message}`);
        }
    }

    async openWorkFolder() {
        console.log('\nüìÅ OUVERTURE DU DOSSIER DE TRAVAIL');
        console.log('-' .repeat(50));

        const workDir = path.join(process.cwd(), '.tmp_silent_processing');
        
        if (fs.existsSync(workDir)) {
            try {
                // Ouvrir le dossier avec l'explorateur Windows
                const { execSync } = require('child_process');
                execSync(`explorer "${workDir}"`, { stdio: 'pipe' });
                console.log('   ‚úÖ Dossier de travail ouvert');
            } catch (error) {
                console.log(`   ‚ùå Erreur lors de l\'ouverture: ${error.message}`);
                console.log(`   üìÅ Chemin manuel: ${workDir}`);
            }
        } else {
            console.log('   ‚ö†Ô∏è Dossier de travail non trouv√©');
            console.log('   üöÄ D√©marrez d\'abord le processus (option 1)');
        }
    }

    async cleanupTempFiles() {
        console.log('\nüßπ NETTOYAGE DES FICHIERS TEMPORAIRES');
        console.log('-' .repeat(50));

        const tempDir = path.join(process.cwd(), '.tmp_silent_processing');
        
        if (fs.existsSync(tempDir)) {
            try {
                // Arr√™ter les processus en cours
                if (this.processor && this.isRunning) {
                    this.processor.stopAllProcesses();
                    this.isRunning = false;
                }

                // Supprimer le dossier temporaire
                fs.removeSync(tempDir);
                console.log('   ‚úÖ Fichiers temporaires supprim√©s');
                console.log('   üöÄ Red√©marrez le processus si n√©cessaire (option 1)');

            } catch (error) {
                console.log(`   ‚ùå Erreur lors du nettoyage: ${error.message}`);
            }
        } else {
            console.log('   ‚úÖ Aucun fichier temporaire √† nettoyer');
        }
    }

    async getUserChoice(prompt) {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        return new Promise((resolve) => {
            rl.question(prompt, (answer) => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // M√©thode pour v√©rifier l'√©tat depuis l'ext√©rieur
    static getCurrentStatus() {
        return SilentBackgroundProcessor.getStatusFromFile();
    }

    // M√©thode pour obtenir les logs depuis l'ext√©rieur
    static getCurrentLogs() {
        return SilentBackgroundProcessor.getLogs();
    }
}

// Gestion des signaux pour un arr√™t propre
process.on('SIGINT', () => {
    console.log('\nüõë Signal SIGINT re√ßu, arr√™t propre...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Signal SIGTERM re√ßu, arr√™t propre...');
    process.exit(0);
});

if (require.main === module) {
    const controller = new SilentController();
    controller.run().catch(console.error);
}

module.exports = SilentController;
