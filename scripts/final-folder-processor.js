#!/usr/bin/env node

/**
 * üöÄ FINAL FOLDER PROCESSOR - BRIEF "B√âTON"
 * 
 * Script de traitement du dossier FINAL pour extraire toutes les informations utiles
 */

const fs = require('fs-extra');
const path = require('path');

class FinalFolderProcessor {
    constructor() {
        this.projectRoot = process.cwd();
        this.finalDir = 'D:\\Download\\FINAL';
        this.results = {
            filesFound: [],
            scriptsExtracted: [],
            configsFound: [],
            totalSize: 0
        };
    }

    async run() {
        try {
            console.log('üöÄ FINAL FOLDER PROCESSOR - BRIEF "B√âTON"');
            console.log('=' .repeat(70));
            console.log('üéØ Traitement du dossier FINAL...\n');

            // 1. V√©rification de l'existence du dossier FINAL
            if (!fs.existsSync(this.finalDir)) {
                console.log('‚ùå Dossier FINAL non trouv√© dans D:\\Download');
                return;
            }

            // 2. Analyse compl√®te du contenu
            await this.analyzeFinalFolder();
            
            // 3. Extraction des √©l√©ments utiles
            await this.extractUsefulElements();
            
            // 4. Rapport final
            this.generateReport();
            
        } catch (error) {
            console.error('‚ùå Erreur lors du traitement du dossier FINAL:', error);
        }
    }

    async analyzeFinalFolder() {
        console.log('üîç Analyse compl√®te du dossier FINAL...');
        
        try {
            const items = fs.readdirSync(this.finalDir, { withFileTypes: true });
            console.log(`   üìÅ ${items.length} √©l√©ments trouv√©s dans FINAL`);
            
            for (const item of items) {
                const itemPath = path.join(this.finalDir, item.name);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    console.log(`   üìÅ ${item.name}/ (dossier)`);
                    await this.analyzeSubDirectory(itemPath, item.name);
                } else {
                    const sizeKB = (stats.size / 1024).toFixed(1);
                    console.log(`   üìÑ ${item.name} (${sizeKB} KB)`);
                    this.results.filesFound.push({
                        name: item.name,
                        path: itemPath,
                        size: stats.size,
                        type: 'file'
                    });
                    this.results.totalSize += stats.size;
                }
            }
            
            console.log('');
            
        } catch (error) {
            console.log(`   ‚ùå Erreur lors de l'analyse: ${error.message}`);
        }
    }

    async analyzeSubDirectory(dirPath, dirName) {
        try {
            const subItems = fs.readdirSync(dirPath, { withFileTypes: true });
            console.log(`      üìä ${subItems.length} sous-√©l√©ments dans ${dirName}`);
            
            for (const subItem of subItems.slice(0, 5)) { // Afficher les 5 premiers
                const subItemPath = path.join(dirPath, subItem.name);
                const subStats = fs.statSync(subItemPath);
                
                if (subStats.isDirectory()) {
                    console.log(`         üìÅ ${subItem.name}/`);
                } else {
                    const sizeKB = (subStats.size / 1024).toFixed(1);
                    console.log(`         üìÑ ${subItem.name} (${sizeKB} KB)`);
                }
            }
            
            if (subItems.length > 5) {
                console.log(`         ... et ${subItems.length - 5} autres √©l√©ments`);
            }
            
        } catch (error) {
            console.log(`         ‚ùå Erreur analyse sous-dossier: ${error.message}`);
        }
    }

    async extractUsefulElements() {
        console.log('üîß Extraction des √©l√©ments utiles...');
        
        // 1. Recherche de scripts
        await this.extractScripts();
        
        // 2. Recherche de configurations
        await this.extractConfigs();
        
        // 3. Recherche de documentation
        await this.extractDocumentation();
        
        console.log('');
    }

    async extractScripts() {
        console.log('   üìú Extraction des scripts...');
        
        try {
            const scriptFiles = this.findFilesByExtension(this.finalDir, ['.js', '.ps1', '.bat', '.sh']);
            console.log(`      üìä ${scriptFiles.length} scripts trouv√©s`);
            
            for (const script of scriptFiles.slice(0, 10)) { // Afficher les 10 premiers
                console.log(`         üìÑ ${path.basename(script)}`);
                this.results.scriptsExtracted.push(script);
            }
            
            if (scriptFiles.length > 10) {
                console.log(`         ... et ${scriptFiles.length - 10} autres scripts`);
            }
            
        } catch (error) {
            console.log(`      ‚ùå Erreur extraction scripts: ${error.message}`);
        }
    }

    async extractConfigs() {
        console.log('   ‚öôÔ∏è Extraction des configurations...');
        
        try {
            const configFiles = this.findFilesByExtension(this.finalDir, ['.json', '.yaml', '.yml', '.xml', '.conf', '.ini']);
            console.log(`      üìä ${configFiles.length} fichiers de configuration trouv√©s`);
            
            for (const config of configFiles.slice(0, 5)) { // Afficher les 5 premiers
                console.log(`         üìÑ ${path.basename(config)}`);
                this.results.configsFound.push(config);
            }
            
            if (configFiles.length > 5) {
                console.log(`         ... et ${configFiles.length - 5} autres configs`);
            }
            
        } catch (error) {
            console.log(`      ‚ùå Erreur extraction configs: ${error.message}`);
        }
    }

    async extractDocumentation() {
        console.log('   üìö Extraction de la documentation...');
        
        try {
            const docFiles = this.findFilesByExtension(this.finalDir, ['.md', '.txt', '.pdf', '.doc', '.docx']);
            console.log(`      üìä ${docFiles.length} fichiers de documentation trouv√©s`);
            
            // Analyser les fichiers de documentation importants
            for (const doc of docFiles.slice(0, 3)) {
                if (doc.toLowerCase().includes('readme') || doc.toLowerCase().includes('guide')) {
                    console.log(`         üìñ ${path.basename(doc)} (IMPORTANT)`);
                    await this.analyzeImportantDocument(doc);
                }
            }
            
        } catch (error) {
            console.log(`      ‚ùå Erreur extraction docs: ${error.message}`);
        }
    }

    async analyzeImportantDocument(docPath) {
        try {
            if (docPath.toLowerCase().endsWith('.md') || docPath.toLowerCase().endsWith('.txt')) {
                const content = fs.readFileSync(docPath, 'utf8');
                const lines = content.split('\n');
                
                console.log(`            üìù ${lines.length} lignes de contenu`);
                
                // Rechercher des informations cl√©s
                const keyInfo = this.extractKeyInformation(content);
                if (keyInfo.length > 0) {
                    console.log(`            üîë Informations cl√©s trouv√©es: ${keyInfo.length}`);
                    for (const info of keyInfo.slice(0, 3)) {
                        console.log(`               üí° ${info}`);
                    }
                }
            }
        } catch (error) {
            console.log(`            ‚ùå Erreur analyse document: ${error.message}`);
        }
    }

    extractKeyInformation(content) {
        const keyInfo = [];
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // Rechercher des informations importantes
            if (trimmedLine.includes('TODO') || trimmedLine.includes('FIXME')) {
                keyInfo.push(`Action requise: ${trimmedLine}`);
            } else if (trimmedLine.includes('IMPORTANT') || trimmedLine.includes('ATTENTION')) {
                keyInfo.push(`Important: ${trimmedLine}`);
            } else if (trimmedLine.includes('Version') || trimmedLine.includes('v3.')) {
                keyInfo.push(`Version: ${trimmedLine}`);
            } else if (trimmedLine.includes('Driver') || trimmedLine.includes('Capability')) {
                keyInfo.push(`Driver/Capability: ${trimmedLine}`);
            }
        }
        
        return keyInfo;
    }

    findFilesByExtension(rootDir, extensions) {
        const files = [];
        
        try {
            const items = fs.readdirSync(rootDir, { withFileTypes: true });
            
            for (const item of items) {
                const itemPath = path.join(rootDir, item.name);
                
                if (item.isDirectory()) {
                    // R√©cursion pour les sous-dossiers
                    files.push(...this.findFilesByExtension(itemPath, extensions));
                } else if (item.isFile()) {
                    const ext = path.extname(item.name).toLowerCase();
                    if (extensions.includes(ext)) {
                        files.push(itemPath);
                    }
                }
            }
        } catch (error) {
            // Ignorer les erreurs d'acc√®s
        }
        
        return files;
    }

    generateReport() {
        console.log('üéØ RAPPORT FINAL DU TRAITEMENT FINAL');
        console.log('=' .repeat(70));
        console.log(`üìä Fichiers trouv√©s: ${this.results.filesFound.length}`);
        console.log(`üìú Scripts extraits: ${this.results.scriptsExtracted.length}`);
        console.log(`‚öôÔ∏è Configurations trouv√©es: ${this.results.configsFound.length}`);
        console.log(`üì¶ Taille totale: ${(this.results.totalSize / 1024 / 1024).toFixed(1)} MB`);
        
        if (this.results.scriptsExtracted.length > 0) {
            console.log('\nüìú SCRIPTS IMPORTANTS TROUV√âS:');
            for (const script of this.results.scriptsExtracted.slice(0, 5)) {
                console.log(`   üìÑ ${path.basename(script)}`);
            }
        }
        
        if (this.results.configsFound.length > 0) {
            console.log('\n‚öôÔ∏è CONFIGURATIONS IMPORTANTES:');
            for (const config of this.results.configsFound.slice(0, 3)) {
                console.log(`   üìÑ ${path.basename(config)}`);
            }
        }
        
        console.log('\nüöÄ PROCHAINES √âTAPES:');
        console.log('   1. ‚úÖ Analyse du dossier FINAL termin√©e');
        console.log('   2. üéØ Int√©gration des scripts utiles');
        console.log('   3. üéØ Application des configurations');
        console.log('   4. üéØ Fusion avec le projet principal');
        
        console.log('\nüéâ TRAITEMENT DU DOSSIER FINAL TERMIN√â AVEC SUCC√àS !');
    }
}

if (require.main === module) {
    const processor = new FinalFolderProcessor();
    processor.run().catch(console.error);
}

module.exports = FinalFolderProcessor;
