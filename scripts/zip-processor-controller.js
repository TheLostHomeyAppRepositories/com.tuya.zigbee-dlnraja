#!/usr/bin/env node
'use strict';

#!/usr/bin/env node

/**
 * üéÆ ZIP PROCESSOR CONTROLLER - BRIEF "B√âTON"
 * 
 * Script de contr√¥le pour g√©rer le processus d'extraction ZIP en arri√®re-plan
 * Permet de d√©marrer, arr√™ter, surveiller et contr√¥ler l'extraction
 */

const BackgroundZipProcessor = require('./background-zip-processor');
const fs = require('fs-extra');
const path = require('path');

class ZipProcessorController {
    constructor() {
        this.processor = null;
        this.isRunning = false;
        this.statusFile = path.join(process.cwd(), '.tmp_background_zip', 'extraction-status.json');
    }

    async run() {
        try {
            console.log('üéÆ ZIP PROCESSOR CONTROLLER - BRIEF "B√âTON"');
            console.log('=' .repeat(70));
            console.log('üéØ Contr√¥leur du processus d\'extraction ZIP...\n');

            // Afficher le menu principal
            await this.showMainMenu();

        } catch (error) {
            console.error('‚ùå Erreur dans le contr√¥leur:', error);
        }
    }

    async showMainMenu() {
        while (true) {
            console.log('\nüéÆ MENU PRINCIPAL - ZIP PROCESSOR');
            console.log('=' .repeat(50));
            console.log('1. üöÄ D√©marrer l\'extraction en arri√®re-plan');
            console.log('2. üìä V√©rifier le statut');
            console.log('3. üìã Afficher les logs');
            console.log('4. üõë Arr√™ter tous les processus');
            console.log('5. üîÑ Red√©marrer le processus');
            console.log('6. üìÅ Ouvrir le dossier d\'extraction');
            console.log('7. üßπ Nettoyer les fichiers temporaires');
            console.log('8. ‚ùå Quitter');
            console.log('');

            const choice = await this.getUserChoice('Choisissez une option (1-8): ');

            switch (choice) {
                case '1':
                    await this.startExtraction();
                    break;
                case '2':
                    await this.checkStatus();
                    break;
                case '3':
                    await this.showLogs();
                    break;
                case '4':
                    await this.stopAllProcesses();
                    break;
                case '5':
                    await this.restartProcess();
                    break;
                case '6':
                    await this.openExtractionFolder();
                    break;
                case '7':
                    await this.cleanupTempFiles();
                    break;
                case '8':
                    console.log('üëã Au revoir !');
                    process.exit(0);
                    break;
                default:
                    console.log('‚ùå Option invalide, veuillez r√©essayer.');
            }

            // Pause avant de revenir au menu
            await this.sleep(2000);
        }
    }

    async startExtraction() {
        console.log('\nüöÄ D√âMARRAGE DE L\'EXTRACTION EN ARRI√àRE-PLAN');
        console.log('-' .repeat(50));

        if (this.isRunning) {
            console.log('   ‚ö†Ô∏è L\'extraction est d√©j√† en cours');
            return;
        }

        try {
            // D√©marrer le processus en arri√®re-plan
            this.processor = new BackgroundZipProcessor();
            this.isRunning = true;

            // Lancer l'extraction dans un processus s√©par√©
            this.processor.run().catch(error => {
                console.log(`   ‚ùå Erreur lors du d√©marrage: ${error.message}`);
                this.isRunning = false;
            });

            console.log('   ‚úÖ Processus d\'extraction d√©marr√© en arri√®re-plan');
            console.log('   üìä Utilisez l\'option 2 pour v√©rifier le statut');

        } catch (error) {
            console.log(`   ‚ùå Erreur lors du d√©marrage: ${error.message}`);
            this.isRunning = false;
        }
    }

    async checkStatus() {
        console.log('\nüìä V√âRIFICATION DU STATUT');
        console.log('-' .repeat(50));

        try {
            if (fs.existsSync(this.statusFile)) {
                const status = JSON.parse(fs.readFileSync(this.statusFile, 'utf8'));
                
                console.log(`   üïê Derni√®re mise √† jour: ${status.lastUpdate}`);
                console.log(`   üìä Total ZIPs: ${status.stats.totalZips}`);
                console.log(`   ‚úÖ Extrait: ${status.stats.extracted}`);
                console.log(`   ‚ùå √âchou√©: ${status.stats.failed}`);
                console.log(`   üîÑ En cours: ${status.stats.inProgress}`);

                if (status.stats.totalZips > 0) {
                    const progress = ((status.stats.extracted + status.stats.failed) / status.stats.totalZips * 100).toFixed(1);
                    console.log(`   üìà Progression: ${progress}%`);
                }

                if (status.processes.length > 0) {
                    console.log('\n   üìã D√©tail des processus:');
                    for (const process of status.processes.slice(0, 5)) {
                        const duration = process.duration || 0;
                        console.log(`      üìÑ ${process.name}: ${process.status} (${duration}s)`);
                    }
                    
                    if (status.processes.length > 5) {
                        console.log(`      ... et ${status.processes.length - 5} autres processus`);
                    }
                }

            } else {
                console.log('   ‚ö†Ô∏è Aucun fichier de statut trouv√©');
                console.log('   üöÄ D√©marrez d\'abord l\'extraction (option 1)');
            }

        } catch (error) {
            console.log(`   ‚ùå Erreur lors de la v√©rification: ${error.message}`);
        }
    }

    async showLogs() {
        console.log('\nüìã AFFICHAGE DES LOGS');
        console.log('-' .repeat(50));

        const logFile = path.join(process.cwd(), '.tmp_background_zip', 'extraction.log');
        
        if (fs.existsSync(logFile)) {
            try {
                const logs = fs.readFileSync(logFile, 'utf8');
                const lines = logs.split('\n');
                
                console.log(`   üìÑ Fichier de log: ${logFile}`);
                console.log(`   üìä Total lignes: ${lines.length}`);
                
                // Afficher les 20 derni√®res lignes
                const recentLines = lines.slice(-20);
                console.log('\n   üìã 20 derni√®res lignes:');
                console.log('   ' + '=' .repeat(40));
                
                for (const line of recentLines) {
                    if (line.trim()) {
                        console.log(`   ${line}`);
                    }
                }

            } catch (error) {
                console.log(`   ‚ùå Erreur lors de la lecture des logs: ${error.message}`);
            }
        } else {
            console.log('   ‚ö†Ô∏è Aucun fichier de log trouv√©');
            console.log('   üöÄ D√©marrez d\'abord l\'extraction (option 1)');
        }
    }

    async stopAllProcesses() {
        console.log('\nüõë ARR√äT DE TOUS LES PROCESSUS');
        console.log('-' .repeat(50));

        if (this.processor && this.isRunning) {
            try {
                this.processor.stopAllProcesses();
                this.isRunning = false;
                console.log('   ‚úÖ Tous les processus arr√™t√©s');
            } catch (error) {
                console.log(`   ‚ùå Erreur lors de l\'arr√™t: ${error.message}`);
            }
        } else {
            console.log('   ‚ö†Ô∏è Aucun processus en cours');
        }
    }

    async restartProcess() {
        console.log('\nüîÑ RED√âMARRAGE DU PROCESSUS');
        console.log('-' .repeat(50));

        try {
            // Arr√™ter le processus actuel
            if (this.processor && this.isRunning) {
                this.processor.stopAllProcesses();
                this.isRunning = false;
                console.log('   ‚úÖ Processus actuel arr√™t√©');
            }

            // Attendre un peu
            await this.sleep(2000);

            // Red√©marrer
            await this.startExtraction();

        } catch (error) {
            console.log(`   ‚ùå Erreur lors du red√©marrage: ${error.message}`);
        }
    }

    async openExtractionFolder() {
        console.log('\nüìÅ OUVERTURE DU DOSSIER D\'EXTRACTION');
        console.log('-' .repeat(50));

        const extractionDir = path.join(process.cwd(), '.tmp_background_zip');
        
        if (fs.existsSync(extractionDir)) {
            try {
                // Ouvrir le dossier avec l'explorateur Windows
                const { execSync } = require('child_process');
                execSync(`explorer "${extractionDir}"`, { stdio: 'pipe' });
                console.log('   ‚úÖ Dossier d\'extraction ouvert');
            } catch (error) {
                console.log(`   ‚ùå Erreur lors de l\'ouverture: ${error.message}`);
                console.log(`   üìÅ Chemin manuel: ${extractionDir}`);
            }
        } else {
            console.log('   ‚ö†Ô∏è Dossier d\'extraction non trouv√©');
            console.log('   üöÄ D√©marrez d\'abord l\'extraction (option 1)');
        }
    }

    async cleanupTempFiles() {
        console.log('\nüßπ NETTOYAGE DES FICHIERS TEMPORAIRES');
        console.log('-' .repeat(50));

        const tempDir = path.join(process.cwd(), '.tmp_background_zip');
        
        if (fs.existsSync(tempDir)) {
            try {
                // Arr√™ter les processus en cours
                if (this.processor && this.isRunning) {
                    this.processor.stopAllProcesses();
                    this.isRunning = false;
                }

                // Supprimer le dossier temporaire
                fs.removeSync(tempDir);
                console.log('   ‚úÖ Fichiers temporaires supprim√©s');
                console.log('   üöÄ Red√©marrez l\'extraction si n√©cessaire (option 1)');

            } catch (error) {
                console.log(`   ‚ùå Erreur lors du nettoyage: ${error.message}`);
            }
        } else {
            console.log('   ‚úÖ Aucun fichier temporaire √† nettoyer');
        }
    }

    async getUserChoice(prompt) {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        return new Promise((resolve) => {
            rl.question(prompt, (answer) => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // M√©thode pour v√©rifier l'√©tat depuis l'ext√©rieur
    static getCurrentStatus() {
        try {
            const statusFile = path.join(process.cwd(), '.tmp_background_zip', 'extraction-status.json');
            if (fs.existsSync(statusFile)) {
                return JSON.parse(fs.readFileSync(statusFile, 'utf8'));
            }
        } catch (error) {
            // Ignorer les erreurs
        }
        return null;
    }
}

// Gestion des signaux pour un arr√™t propre
process.on('SIGINT', () => {
    console.log('\nüõë Signal SIGINT re√ßu, arr√™t propre...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Signal SIGTERM re√ßu, arr√™t propre...');
    process.exit(0);
});

if (require.main === module) {
    const controller = new ZipProcessorController();
    controller.run().catch(console.error);
}

module.exports = ZipProcessorController;
