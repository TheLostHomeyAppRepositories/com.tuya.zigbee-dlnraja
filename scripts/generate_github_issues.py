#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de G√©n√©ration Automatique d'Issues GitHub
Phase 11 : Syst√®me complet pour drivers incomplets
"""

import os
import json
import re
from datetime import datetime
from pathlib import Path

# Configuration
LANGS = ['fr', 'en', 'ta', 'nl']
ISSUE_TEMPLATES = {
    'fr': {
        'title': 'Driver incomplet d√©tect√© : {driver_id}',
        'body': '''## üö® Driver Incomplet D√©tect√©

**Driver ID :** `{driver_id}`
**Nom :** {driver_name}
**Statut :** {status}
**Date de d√©tection :** {timestamp}

### üìã Informations du Driver
- **Fabricant :** {manufacturer}
- **Mod√®le :** {model}
- **Capacit√©s :** {capabilities}
- **Cat√©gorie :** {category}

### üîç Probl√®mes Identifi√©s
{issues_list}

### üéØ Actions Requises
- [ ] Compl√©ter les m√©tadonn√©es manquantes
- [ ] Ajouter les capacit√©s manquantes
- [ ] V√©rifier la compatibilit√© SDK3
- [ ] Tester le driver
- [ ] Mettre √† jour la documentation

### üìù Notes
{notes}

---
*G√©n√©r√© automatiquement par GPT-4, Cursor, PowerShell*
'''
    },
    'en': {
        'title': 'Incomplete driver detected: {driver_id}',
        'body': '''## üö® Incomplete Driver Detected

**Driver ID :** `{driver_id}`
**Name :** {driver_name}
**Status :** {status}
**Detection Date :** {timestamp}

### üìã Driver Information
- **Manufacturer :** {manufacturer}
- **Model :** {model}
- **Capabilities :** {capabilities}
- **Category :** {category}

### üîç Identified Issues
{issues_list}

### üéØ Required Actions
- [ ] Complete missing metadata
- [ ] Add missing capabilities
- [ ] Verify SDK3 compatibility
- [ ] Test the driver
- [ ] Update documentation

### üìù Notes
{notes}

---
*Generated automatically by GPT-4, Cursor, PowerShell*
'''
    },
    'ta': {
        'title': '‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Æ±‡Øç‡Æ± driver ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ : {driver_id}',
        'body': '''## üö® ‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Æ±‡Øç‡Æ± Driver ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ

**Driver ID :** `{driver_id}`
**‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç :** {driver_name}
**‡Æ®‡Æø‡Æ≤‡Øà :** {status}
**‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æ§‡Øá‡Æ§‡Æø :** {timestamp}

### üìã Driver ‡Æ§‡Æï‡Æµ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç
- **‡Æâ‡Æ±‡Øç‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç :** {manufacturer}
- **‡ÆÆ‡Ææ‡Æü‡Æ≤‡Øç :** {model}
- **‡Æ§‡Æø‡Æ±‡Æ©‡Øç‡Æï‡Æ≥‡Øç :** {capabilities}
- **‡Æµ‡Æï‡Øà :** {category}

### üîç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æ™‡Æø‡Æ∞‡Æö‡Øç‡Æö‡Æø‡Æ©‡Øà‡Æï‡Æ≥‡Øç
{issues_list}

### üéØ ‡Æ§‡Øá‡Æµ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç
- [ ] ‡Æï‡Ææ‡Æ£‡Ææ‡ÆÆ‡Æ≤‡Øç ‡Æ™‡Øã‡Æ© metadata ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç
- [ ] ‡Æï‡Ææ‡Æ£‡Ææ‡ÆÆ‡Æ≤‡Øç ‡Æ™‡Øã‡Æ© ‡Æ§‡Æø‡Æ±‡Æ©‡Øç‡Æï‡Æ≥‡Øà ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç
- [ ] SDK3 ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ ‡Æ§‡Æ©‡Øç‡ÆÆ‡Øà‡ÆØ‡Øà ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç
- [ ] Driver ‡Æê ‡Æö‡Øã‡Æ§‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç
- [ ] ‡ÆÜ‡Æµ‡Æ£‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Øà ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç

### üìù ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç
{notes}

---
*GPT-4, Cursor, PowerShell ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æ§‡Ææ‡Æ©‡Ææ‡Æï ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ*
'''
    },
    'nl': {
        'title': 'Onvolledige driver gedetecteerd: {driver_id}',
        'body': '''## üö® Onvolledige Driver Gedetecteerd

**Driver ID :** `{driver_id}`
**Naam :** {driver_name}
**Status :** {status}
**Detectiedatum :** {timestamp}

### üìã Driver Informatie
- **Fabrikant :** {manufacturer}
- **Model :** {model}
- **Mogelijkheden :** {capabilities}
- **Categorie :** {category}

### üîç Ge√Ødentificeerde Problemen
{issues_list}

### üéØ Vereiste Acties
- [ ] Ontbrekende metadata voltooien
- [ ] Ontbrekende mogelijkheden toevoegen
- [ ] SDK3 compatibiliteit controleren
- [ ] Driver testen
- [ ] Documentatie bijwerken

### üìù Notities
{notes}

---
*Automatisch gegenereerd door GPT-4, Cursor, PowerShell*
'''
    }
}

def analyze_driver_completeness(driver_path):
    """Analyse la compl√©tude d'un driver"""
    compose_path = os.path.join(driver_path, 'driver.compose.json')
    
    if not os.path.isfile(compose_path):
        return {
            'is_incomplete': True,
            'issues': ['Fichier driver.compose.json manquant'],
            'severity': 'high'
        }
    
    try:
        with open(compose_path, encoding='utf-8-sig') as f:
            data = json.load(f)
    except Exception as e:
        return {
            'is_incomplete': True,
            'issues': [f'Erreur de parsing JSON: {str(e)}'],
            'severity': 'high'
        }
    
    issues = []
    severity = 'low'
    
    # V√©rifier les champs requis
    required_fields = ['id', 'name', 'class', 'capabilities']
    for field in required_fields:
        if field not in data:
            issues.append(f'Champ requis manquant: {field}')
            severity = 'medium'
    
    # V√©rifier les noms multilingues
    if 'name' in data:
        name_data = data['name']
        if isinstance(name_data, dict):
            for lang in LANGS:
                if lang not in name_data or not name_data[lang]:
                    issues.append(f'Nom manquant pour la langue: {lang}')
        else:
            issues.append('Noms multilingues manquants')
    
    # V√©rifier les capacit√©s
    if 'capabilities' in data and not data['capabilities']:
        issues.append('Aucune capacit√© d√©finie')
        severity = 'medium'
    
    # V√©rifier les m√©tadonn√©es Zigbee
    if 'zigbee' not in data:
        issues.append('M√©tadonn√©es Zigbee manquantes')
        severity = 'medium'
    else:
        zigbee_data = data['zigbee']
        if 'manufacturerName' not in zigbee_data or not zigbee_data['manufacturerName']:
            issues.append('Fabricant(s) manquant(s)')
        if 'productId' not in zigbee_data or not zigbee_data['productId']:
            issues.append('ID(s) produit manquant(s)')
    
    # V√©rifier les instructions
    if 'zigbee' in data and 'learnmode' in data['zigbee']:
        learnmode = data['zigbee']['learnmode']
        if 'instruction' not in learnmode:
            issues.append('Instructions d\'appairage manquantes')
    
    return {
        'is_incomplete': len(issues) > 0,
        'issues': issues,
        'severity': severity,
        'data': data
    }

def generate_issue_content(driver_id, analysis, lang='fr'):
    """G√©n√®re le contenu de l'issue pour une langue donn√©e"""
    template = ISSUE_TEMPLATES[lang]
    
    # Extraire les donn√©es du driver
    driver_data = analysis.get('data', {})
    
    # G√©rer le cas o√π name est une string au lieu d'un dict
    name_data = driver_data.get('name', {})
    if isinstance(name_data, str):
        driver_name = name_data
    else:
        driver_name = name_data.get(lang, name_data.get('en', driver_id))
    
    # Pr√©parer les donn√©es pour le template
    template_data = {
        'driver_id': driver_id,
        'driver_name': driver_name,
        'status': 'incomplete',
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'manufacturer': ', '.join(driver_data.get('zigbee', {}).get('manufacturerName', ['Unknown'])),
        'model': ', '.join(driver_data.get('zigbee', {}).get('productId', ['Unknown'])),
        'capabilities': ', '.join(driver_data.get('capabilities', [])),
        'category': driver_data.get('class', 'unknown'),
        'issues_list': '\n'.join([f'- {issue}' for issue in analysis['issues']]),
        'notes': f'S√©v√©rit√©: {analysis["severity"]}\nNombre de probl√®mes: {len(analysis["issues"])}'
    }
    
    return {
        'title': template['title'].format(**template_data),
        'body': template['body'].format(**template_data)
    }

def scan_all_drivers():
    """Scanne tous les drivers et d√©tecte les incomplets"""
    incomplete_drivers = []
    
    # Scanner les dossiers drivers
    driver_dirs = ['drivers/sdk3', 'drivers/in_progress', 'drivers/legacy']
    
    for base_dir in driver_dirs:
        if not os.path.isdir(base_dir):
            continue
            
        for driver_name in os.listdir(base_dir):
            driver_path = os.path.join(base_dir, driver_name)
            
            if os.path.isdir(driver_path):
                analysis = analyze_driver_completeness(driver_path)
                
                if analysis['is_incomplete']:
                    incomplete_drivers.append({
                        'id': driver_name,
                        'path': driver_path,
                        'analysis': analysis
                    })
    
    return incomplete_drivers

def generate_issues_for_all_languages(incomplete_drivers):
    """G√©n√®re les issues pour toutes les langues"""
    all_issues = {}
    
    for driver in incomplete_drivers:
        driver_id = driver['id']
        analysis = driver['analysis']
        
        driver_issues = {}
        for lang in LANGS:
            driver_issues[lang] = generate_issue_content(driver_id, analysis, lang)
        
        all_issues[driver_id] = driver_issues
    
    return all_issues

def save_issues_to_files(issues):
    """Sauvegarde les issues dans des fichiers"""
    os.makedirs('issues', exist_ok=True)
    
    for driver_id, driver_issues in issues.items():
        for lang, issue_content in driver_issues.items():
            filename = f'issues/{driver_id}_{lang}_issue.md'
            
            content = f"""# {issue_content['title']}

{issue_content['body']}
"""
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
    
    # Cr√©er un rapport global
    report = {
        'timestamp': datetime.now().isoformat(),
        'total_incomplete_drivers': len(issues),
        'languages': LANGS,
        'drivers': list(issues.keys()),
        'summary': {
            'high_severity': sum(1 for d in issues.values() if any('high' in str(v) for v in d.values())),
            'medium_severity': sum(1 for d in issues.values() if any('medium' in str(v) for v in d.values())),
            'low_severity': sum(1 for d in issues.values() if any('low' in str(v) for v in d.values()))
        }
    }
    
    with open('issues/ISSUES_REPORT.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, ensure_ascii=False, indent=2)

def main():
    """Fonction principale"""
    print("üöÄ D√©but de la g√©n√©ration automatique d'issues GitHub...")
    
    # 1. Scanner tous les drivers
    print("üîç Scan des drivers...")
    incomplete_drivers = scan_all_drivers()
    
    if not incomplete_drivers:
        print("‚úÖ Aucun driver incomplet d√©tect√©!")
        return
    
    print(f"‚ö†Ô∏è {len(incomplete_drivers)} drivers incomplets d√©tect√©s")
    
    # 2. G√©n√©rer les issues pour toutes les langues
    print("üìù G√©n√©ration des issues multilingues...")
    issues = generate_issues_for_all_languages(incomplete_drivers)
    
    # 3. Sauvegarder les issues
    print("üíæ Sauvegarde des issues...")
    save_issues_to_files(issues)
    
    # 4. Afficher le r√©sum√©
    print("\nüéâ G√âN√âRATION D'ISSUES TERMIN√âE!")
    print(f"üìä R√©sum√©:")
    print(f"- {len(incomplete_drivers)} drivers incomplets")
    print(f"- {len(LANGS)} langues support√©es")
    print(f"- {len(incomplete_drivers) * len(LANGS)} issues g√©n√©r√©es")
    print(f"- Fichiers sauvegard√©s dans le dossier 'issues/'")
    
    # Afficher les drivers incomplets
    print("\nüìã Drivers incomplets d√©tect√©s:")
    for driver in incomplete_drivers:
        severity = driver['analysis']['severity']
        issues_count = len(driver['analysis']['issues'])
        print(f"- {driver['id']} ({severity}, {issues_count} probl√®mes)")

if __name__ == '__main__':
    main() 