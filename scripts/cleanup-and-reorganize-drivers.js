#!/usr/bin/env node

/**
 * Script de nettoyage et r√©organisation compl√®te des drivers
 * Utilise les sources .tmp* pour enrichir et corriger la structure
 * Auteur: dlnraja
 * Date: 2025-08-10
 */

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

// Configuration
const VERBOSE = true;
const DRIVERS_DIR = path.join(process.cwd(), 'drivers');
const TMP_SOURCES_DIR = path.join(process.cwd(), '.tmp_tuya_zip_work');
const BACKUP_DIR = path.join(process.cwd(), `.backup-cleanup-${Date.now()}`);

// Fonction de logging
function log(message, level = 'info') {
    const timestamp = new Date().toISOString();
    const prefix = level === 'error' ? '‚ùå' : level === 'warn' ? '‚ö†Ô∏è' : '‚úÖ';
    console.log(`[${timestamp}] ${prefix} [CLEANUP] ${message}`);
}

// Fonction pour ex√©cuter des commandes
function run(cmd, args, description) {
    if (VERBOSE) log(`üöÄ Ex√©cution: ${cmd} ${args.join(' ')} - ${description}`);
    
    const result = spawnSync(cmd, args, {
        stdio: 'inherit',
        timeout: 300000, // 5 minutes
        cwd: process.cwd()
    });
    
    if (result.status === 0) {
        if (VERBOSE) log(`‚úÖ Succ√®s: ${description}`);
        return true;
    } else {
        log(`‚ùå √âchec: ${description} (code: ${result.status})`, 'error');
        if (result.error) {
            log(`üí• Erreur: ${result.error.message}`, 'error');
        }
        return false;
    }
}

// Fonction pour cr√©er un backup
function createBackup() {
    log('üìã √âTAPE 1: Cr√©ation du backup');
    
    try {
        if (!fs.existsSync(BACKUP_DIR)) {
            fs.mkdirSync(BACKUP_DIR, { recursive: true });
        }
        
        // Copier le dossier drivers
        if (fs.existsSync(DRIVERS_DIR)) {
            run('xcopy', [DRIVERS_DIR, BACKUP_DIR, '/E', '/I', '/H', '/Y'], 'Backup des drivers');
        }
        
        log('‚úÖ Backup cr√©√© dans: ' + BACKUP_DIR);
        return true;
    } catch (error) {
        log(`‚ö†Ô∏è √âchec du backup: ${error.message}`, 'warn');
        return false;
    }
}

// Fonction pour analyser les sources .tmp*
function analyzeTmpSources() {
    log('üìã √âTAPE 2: Analyse des sources .tmp*');
    
    if (!fs.existsSync(TMP_SOURCES_DIR)) {
        log('‚ö†Ô∏è Dossier .tmp_tuya_zip_work non trouv√©', 'warn');
        return [];
    }
    
    try {
        const sources = [];
        const items = fs.readdirSync(TMP_SOURCES_DIR);
        
        for (const item of items) {
            const itemPath = path.join(TMP_SOURCES_DIR, item);
            const stats = fs.statSync(itemPath);
            
            if (stats.isDirectory()) {
                // Analyser le contenu du dossier
                const driverFiles = [];
                const walkDir = (dir) => {
                    const files = fs.readdirSync(dir);
                    for (const file of files) {
                        const filePath = path.join(dir, file);
                        const fileStats = fs.statSync(filePath);
                        
                        if (fileStats.isDirectory()) {
                            walkDir(filePath);
                        } else if (file === 'driver.compose.json' || file === 'driver.json') {
                            driverFiles.push({
                                path: filePath,
                                relativePath: path.relative(TMP_SOURCES_DIR, filePath),
                                name: path.basename(path.dirname(filePath))
                            });
                        }
                    }
                };
                
                walkDir(itemPath);
                
                sources.push({
                    name: item,
                    path: itemPath,
                    driverCount: driverFiles.length,
                    driverFiles: driverFiles
                });
                
                log(`üìÅ Source: ${item} (${driverFiles.length} drivers)`);
            }
        }
        
        log(`‚úÖ ${sources.length} sources .tmp* analys√©es`);
        return sources;
    } catch (error) {
        log(`‚ùå Erreur lors de l'analyse des sources .tmp*: ${error.message}`, 'error');
        return [];
    }
}

// Fonction pour nettoyer les noms de dossiers √©tranges
function cleanStrangeFolderNames() {
    log('üìã √âTAPE 3: Nettoyage des noms de dossiers √©tranges');
    
    try {
        const cleanFolder = (dirPath) => {
            if (!fs.existsSync(dirPath)) return;
            
            const items = fs.readdirSync(dirPath);
            for (const item of items) {
                const itemPath = path.join(dirPath, item);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    // Nettoyer les noms de dossiers
                    let cleanName = item;
                    
                    // Remplacer les caract√®res √©tranges
                    cleanName = cleanName.replace(/[^\w\s-]/g, '_');
                    cleanName = cleanName.replace(/\s+/g, '_');
                    cleanName = cleanName.replace(/_+/g, '_');
                    cleanName = cleanName.replace(/^_+|_+$/g, '');
                    
                    // Normaliser les noms sp√©cifiques
                    if (cleanName.includes('tuya')) {
                        cleanName = cleanName.replace(/tuya/gi, 'tuya');
                    }
                    if (cleanName.includes('smart')) {
                        cleanName = cleanName.replace(/smart/gi, 'smart');
                    }
                    if (cleanName.includes('cover')) {
                        cleanName = cleanName.replace(/cover/gi, 'cover');
                    }
                    if (cleanName.includes('lock')) {
                        cleanName = cleanName.replace(/lock/gi, 'lock');
                    }
                    if (cleanName.includes('switch')) {
                        cleanName = cleanName.replace(/switch/gi, 'switch');
                    }
                    if (cleanName.includes('sensor')) {
                        cleanName = cleanName.replace(/sensor/gi, 'sensor');
                    }
                    if (cleanName.includes('plug')) {
                        cleanName = cleanName.replace(/plug/gi, 'plug');
                    }
                    if (cleanName.includes('light')) {
                        cleanName = cleanName.replace(/light/gi, 'light');
                    }
                    
                    // Si le nom a chang√©, renommer le dossier
                    if (cleanName !== item && cleanName.length > 0) {
                        const newPath = path.join(dirPath, cleanName);
                        
                        if (!fs.existsSync(newPath)) {
                            try {
                                fs.renameSync(itemPath, newPath);
                                log(`   üîÑ Renomm√©: ${item} ‚Üí ${cleanName}`);
                                cleanFolder(newPath); // Continuer avec le nouveau chemin
                            } catch (error) {
                                log(`   ‚ö†Ô∏è Impossible de renommer ${item}: ${error.message}`, 'warn');
                                cleanFolder(itemPath); // Continuer avec l'ancien chemin
                            }
                        } else {
                            log(`   ‚ö†Ô∏è Destination existe d√©j√†: ${cleanName}`, 'warn');
                            cleanFolder(itemPath); // Continuer avec l'ancien chemin
                        }
                    } else {
                        cleanFolder(itemPath); // Continuer avec le chemin actuel
                    }
                }
            }
        };
        
        // Nettoyer drivers/tuya
        const tuyaPath = path.join(DRIVERS_DIR, 'tuya');
        if (fs.existsSync(tuyaPath)) {
            log('   üßπ Nettoyage de drivers/tuya');
            cleanFolder(tuyaPath);
        }
        
        log('‚úÖ Noms de dossiers nettoy√©s');
        return true;
    } catch (error) {
        log(`‚ùå Erreur lors du nettoyage: ${error.message}`, 'error');
        return false;
    }
}

// Fonction pour r√©organiser la structure
function reorganizeStructure() {
    log('üìã √âTAPE 4: R√©organisation de la structure');
    
    try {
        const tuyaPath = path.join(DRIVERS_DIR, 'tuya');
        if (!fs.existsSync(tuyaPath)) {
            log('‚ö†Ô∏è Dossier drivers/tuya non trouv√©', 'warn');
            return false;
        }
        
        // Cr√©er la structure standard
        const standardCategories = [
            'light', 'switch', 'plug', 'sensor', 'sensor-motion', 'sensor-temp',
            'sensor-contact', 'sensor-leak', 'cover', 'lock', 'meter-power', 'other'
        ];
        
        for (const category of standardCategories) {
            const categoryPath = path.join(tuyaPath, category);
            if (!fs.existsSync(categoryPath)) {
                fs.mkdirSync(categoryPath, { recursive: true });
                log(`   üìÅ Cat√©gorie cr√©√©e: ${category}`);
            }
        }
        
        // D√©placer les drivers dans les bonnes cat√©gories
        const items = fs.readdirSync(tuyaPath);
        for (const item of items) {
            const itemPath = path.join(tuyaPath, item);
            const stats = fs.statSync(itemPath);
            
            if (stats.isDirectory() && !standardCategories.includes(item)) {
                // D√©terminer la cat√©gorie appropri√©e
                let targetCategory = 'other';
                
                if (item.includes('light') || item.includes('bulb') || item.includes('lamp')) {
                    targetCategory = 'light';
                } else if (item.includes('switch') || item.includes('button')) {
                    targetCategory = 'switch';
                } else if (item.includes('plug') || item.includes('outlet')) {
                    targetCategory = 'plug';
                } else if (item.includes('sensor')) {
                    if (item.includes('motion')) {
                        targetCategory = 'sensor-motion';
                    } else if (item.includes('temp') || item.includes('temperature')) {
                        targetCategory = 'sensor-temp';
                    } else if (item.includes('contact') || item.includes('door')) {
                        targetCategory = 'sensor-contact';
                    } else if (item.includes('leak') || item.includes('water')) {
                        targetCategory = 'sensor-leak';
                    } else {
                        targetCategory = 'sensor';
                    }
                } else if (item.includes('cover') || item.includes('curtain') || item.includes('blind')) {
                    targetCategory = 'cover';
                } else if (item.includes('lock') || item.includes('door')) {
                    targetCategory = 'lock';
                } else if (item.includes('meter') || item.includes('power') || item.includes('energy')) {
                    targetCategory = 'meter-power';
                }
                
                const targetPath = path.join(tuyaPath, targetCategory, item);
                
                if (!fs.existsSync(targetPath)) {
                    try {
                        fs.renameSync(itemPath, targetPath);
                        log(`   üì¶ D√©plac√©: ${item} ‚Üí ${targetCategory}/${item}`);
                    } catch (error) {
                        log(`   ‚ö†Ô∏è Impossible de d√©placer ${item}: ${error.message}`, 'warn');
                    }
                } else {
                    log(`   ‚ö†Ô∏è Destination existe d√©j√†: ${targetCategory}/${item}`, 'warn');
                }
            }
        }
        
        log('‚úÖ Structure r√©organis√©e');
        return true;
    } catch (error) {
        log(`‚ùå Erreur lors de la r√©organisation: ${error.message}`, 'error');
        return false;
    }
}

// Fonction pour nettoyer les dossiers vides
function cleanupEmptyDirectories() {
    log('üìã √âTAPE 5: Nettoyage des dossiers vides');
    
    try {
        const removeEmptyDirs = (dirPath) => {
            if (!fs.existsSync(dirPath)) return;
            
            const items = fs.readdirSync(dirPath);
            for (const item of items) {
                const itemPath = path.join(dirPath, item);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    removeEmptyDirs(itemPath);
                    
                    // V√©rifier si le dossier est vide apr√®s nettoyage
                    const remainingItems = fs.readdirSync(itemPath);
                    if (remainingItems.length === 0) {
                        try {
                            fs.rmdirSync(itemPath);
                            log(`   üóëÔ∏è Dossier vide supprim√©: ${path.relative(DRIVERS_DIR, itemPath)}`);
                        } catch (error) {
                            log(`   ‚ö†Ô∏è Impossible de supprimer ${itemPath}: ${error.message}`, 'warn');
                        }
                    }
                }
            }
        };
        
        removeEmptyDirs(DRIVERS_DIR);
        log('‚úÖ Dossiers vides nettoy√©s');
        return true;
    } catch (error) {
        log(`‚ùå Erreur lors du nettoyage des dossiers vides: ${error.message}`, 'error');
        return false;
    }
}

// Fonction pour g√©n√©rer le rapport final
function generateFinalReport() {
    log('üìã √âTAPE 6: G√©n√©ration du rapport final');
    
    try {
        const report = {
            timestamp: new Date().toISOString(),
            backupDir: BACKUP_DIR,
            structure: {
                zigbee: {},
                tuya: {}
            }
        };
        
        // Analyser la structure zigbee
        const zigbeePath = path.join(DRIVERS_DIR, 'zigbee');
        if (fs.existsSync(zigbeePath)) {
            const zigbeeVendors = fs.readdirSync(zigbeePath);
            for (const vendor of zigbeeVendors) {
                const vendorPath = path.join(zigbeePath, vendor);
                const stats = fs.statSync(vendorPath);
                
                if (stats.isDirectory()) {
                    report.structure.zigbee[vendor] = {};
                    const categories = fs.readdirSync(vendorPath);
                    
                    for (const category of categories) {
                        const categoryPath = path.join(vendorPath, category);
                        const catStats = fs.statSync(categoryPath);
                        
                        if (catStats.isDirectory()) {
                            const drivers = fs.readdirSync(categoryPath);
                            report.structure.zigbee[vendor][category] = drivers.length;
                        }
                    }
                }
            }
        }
        
        // Analyser la structure tuya
        const tuyaPath = path.join(DRIVERS_DIR, 'tuya');
        if (fs.existsSync(tuyaPath)) {
            const tuyaCategories = fs.readdirSync(tuyaPath);
            for (const category of tuyaCategories) {
                const categoryPath = path.join(tuyaPath, category);
                const stats = fs.statSync(categoryPath);
                
                if (stats.isDirectory()) {
                    const drivers = fs.readdirSync(categoryPath);
                    report.structure.tuya[category] = drivers.length;
                }
            }
        }
        
        // Sauvegarder le rapport
        const reportPath = path.join(process.cwd(), 'CLEANUP_REPORT.json');
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        
        log('‚úÖ Rapport final g√©n√©r√©: CLEANUP_REPORT.json');
        
        // Afficher un r√©sum√©
        console.log('\nüìä R√âSUM√â DE LA STRUCTURE FINALE:');
        console.log('=====================================');
        
        if (Object.keys(report.structure.zigbee).length > 0) {
            console.log('\nüìÅ drivers/zigbee/');
            for (const [vendor, categories] of Object.entries(report.structure.zigbee)) {
                console.log(`   üìÅ ${vendor}/`);
                for (const [category, count] of Object.entries(categories)) {
                    console.log(`      üìÅ ${category}/ (${count} drivers)`);
                }
            }
        }
        
        if (Object.keys(report.structure.tuya).length > 0) {
            console.log('\nüìÅ drivers/tuya/');
            for (const [category, count] of Object.entries(report.structure.tuya)) {
                console.log(`   üìÅ ${category}/ (${count} drivers)`);
            }
        }
        
        return true;
    } catch (error) {
        log(`‚ùå Erreur lors de la g√©n√©ration du rapport: ${error.message}`, 'error');
        return false;
    }
}

// Fonction principale
async function main() {
    log('üöÄ D√âMARRAGE DU NETTOYAGE ET DE LA R√âORGANISATION COMPL√àTE');
    console.log('========================================================');
    
    try {
        // 1. Backup
        if (!createBackup()) {
            log('‚ö†Ô∏è Backup √©chou√©, continuation...', 'warn');
        }
        
        // 2. Analyser les sources .tmp*
        const tmpSources = analyzeTmpSources();
        
        // 3. Nettoyer les noms de dossiers
        if (!cleanStrangeFolderNames()) {
            log('‚ùå √âchec du nettoyage des noms', 'error');
            return false;
        }
        
        // 4. R√©organiser la structure
        if (!reorganizeStructure()) {
            log('‚ùå √âchec de la r√©organisation', 'error');
            return false;
        }
        
        // 5. Nettoyer les dossiers vides
        if (!cleanupEmptyDirectories()) {
            log('‚ùå √âchec du nettoyage des dossiers vides', 'error');
            return false;
        }
        
        // 6. Rapport final
        if (!generateFinalReport()) {
            log('‚ùå √âchec de la g√©n√©ration du rapport', 'error');
            return false;
        }
        
        log('üéâ NETTOYAGE ET R√âORGANISATION TERMIN√âS AVEC SUCC√àS !');
        console.log('\nüéØ Prochaines √©tapes recommand√©es:');
        console.log('   1. ‚úÖ Structure des drivers nettoy√©e et r√©organis√©e');
        console.log('   2. üîÑ Ex√©cuter enrich-drivers.js avec --apply');
        console.log('   3. üîÑ Ex√©cuter verify-coherence-and-enrich.js');
        console.log('   4. üîÑ Valider l\'app Homey');
        
        return true;
        
    } catch (error) {
        log(`üí• ERREUR FATALE: ${error.message}`, 'error');
        log(`üìö Stack trace: ${error.stack}`, 'error');
        return false;
    }
}

// Gestion des signaux
process.on('SIGINT', () => {
    log('‚ö†Ô∏è Interruption re√ßue, arr√™t en cours...', 'warn');
    process.exit(0);
});

process.on('SIGTERM', () => {
    log('‚ö†Ô∏è Terminaison re√ßue, arr√™t en cours...', 'warn');
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    log(`üí• Exception non g√©r√©e: ${error.message}`, 'error');
    log(`üìö Stack trace: ${error.stack}`, 'error');
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    log(`üí• Promesse rejet√©e non g√©r√©e: ${reason}`, 'error');
    process.exit(1);
});

// Ex√©cution
if (require.main === module) {
    main().then(success => {
        process.exit(success ? 0 : 1);
    }).catch(error => {
        log(`üí• Erreur fatale: ${error.message}`, 'error');
        process.exit(1);
    });
}

module.exports = { main, createBackup, analyzeTmpSources, cleanStrangeFolderNames, reorganizeStructure, cleanupEmptyDirectories, generateFinalReport };
