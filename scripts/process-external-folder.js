// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node const fs = require('fs'); const path = require('path'); console.log('üöÄ PROCESS-EXTERNAL-FOLDER - TRAITEMENT COMPLET'); console.log('=' .repeat(60)); class ExternalFolderProcessor { constructor() { this.startTime = Date.now(); this.targetFolder = 'D:\\Download\\fold'; this.report = { timestamp: new Date().toISOString(), folderPath: this.targetFolder, actions: [], filesProcessed: 0, foldersProcessed: 0, errors: [], warnings: [], structure: {}, subjects: [], sources: [] }; } async processAll() { console.log('üéØ D√©marrage du traitement du dossier externe...'); console.log(`üìÅ Dossier cible: ${this.targetFolder}`); try { // 1. V√©rifier l'existence du dossier await this.checkFolderExists(); // 2. Analyser la structure await this.analyzeStructure(); // 3. Identifier les sujets await this.identifySubjects(); // 4. Identifier les sources await this.identifySources(); // 5. Traiter les fichiers await this.processFiles(); // 6. Organiser le contenu await this.organizeContent(); // 7. G√©n√©rer la documentation await this.generateDocumentation(); // 8. Cr√©er les rapports await this.createReports(); const duration = Date.now() - this.startTime; console.log(`‚úÖ Traitement termin√© en ${duration}ms`); } catch (error) { console.error('‚ùå Erreur traitement:', error.message); this.report.errors.push(error.message); } } async checkFolderExists() { console.log('\nüîç 1. V√©rification de l\'existence du dossier...'); if (!fs.existsSync(this.targetFolder)) { throw new Error(`Le dossier ${this.targetFolder} n'existe pas`); } const stats = fs.statSync(this.targetFolder); if (!stats.isDirectory()) { throw new Error(`${this.targetFolder} n'est pas un dossier`); } console.log('‚úÖ Dossier trouv√© et accessible'); this.report.actions.push('Dossier v√©rifi√© et accessible'); } async analyzeStructure() { console.log('\nüìÅ 2. Analyse de la structure...'); this.report.structure = await this.scanDirectory(this.targetFolder); console.log(`üìä Structure analys√©e: ${Object.keys(this.report.structure).length} √©l√©ments`); this.report.actions.push('Structure analys√©e'); } async scanDirectory(dirPath, depth = 0) { const structure = { path: dirPath, name: path.basename(dirPath), type: 'directory', depth: depth, children: [], files: [], stats: null }; try { const items = fs.readdirSync(dirPath); for (const item of items) { const fullPath = path.join(dirPath, item); const stats = fs.statSync(fullPath); if (stats.isDirectory()) { const childStructure = await this.scanDirectory(fullPath, depth + 1); structure.children.push(childStructure); } else { structure.files.push({ name: item, path: fullPath, size: stats.size, modified: stats.mtime, type: this.getFileType(item) }); } } structure.stats = { totalFiles: this.countFiles(structure), totalDirectories: this.countDirectories(structure), totalSize: this.calculateSize(structure) }; } catch (error) { console.log(`‚ö†Ô∏è Erreur lecture ${dirPath}: ${error.message}`); } return structure; } getFileType(filename) { const ext = path.extname(filename).toLowerCase(); const textExtensions = ['.txt', '.md', '.json', '.js', '.py', '.java', '.cpp', '.c', '.h', '.html', '.css', '.xml', '.yaml', '.yml']; const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico']; const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv']; const audioExtensions = ['.mp3', '.wav', '.flac', '.aac', '.ogg']; const archiveExtensions = ['.zip', '.rar', '.7z', '.tar', '.gz']; if (textExtensions.includes(ext)) return 'text'; if (imageExtensions.includes(ext)) return 'image'; if (videoExtensions.includes(ext)) return 'video'; if (audioExtensions.includes(ext)) return 'audio'; if (archiveExtensions.includes(ext)) return 'archive'; return 'unknown'; } countFiles(structure) { let count = structure.files.length; for (const child of structure.children) { count += this.countFiles(child); } return count; } countDirectories(structure) { let count = 1; // Include current directory for (const child of structure.children) { count += this.countDirectories(child); } return count; } calculateSize(structure) { let size = 0; for (const file of structure.files) { size += file.size; } for (const child of structure.children) { size += this.calculateSize(child); } return size; } async identifySubjects() { console.log('\nüéØ 3. Identification des sujets...'); const subjects = new Set(); // Analyser les noms de fichiers et dossiers pour identifier les sujets this.extractSubjectsFromStructure(this.report.structure, subjects); this.report.subjects = Array.from(subjects); console.log(`üìä Sujets identifi√©s: ${this.report.subjects.length}`); for (const subject of this.report.subjects) { console.log(` - ${subject}`); } this.report.actions.push(`Identifi√© ${this.report.subjects.length} sujets`); } extractSubjectsFromStructure(structure, subjects) { // Analyser le nom du dossier/fichier const name = structure.name.toLowerCase(); const words = name.split(/[_\-\s\.]/); for (const word of words) { if (word.length > 2 && !this.isCommonWord(word)) { subjects.add(word); } } // Analyser les fichiers for (const file of structure.files) { const fileName = file.name.toLowerCase(); const fileWords = fileName.split(/[_\-\s\.]/); for (const word of fileWords) { if (word.length > 2 && !this.isCommonWord(word)) { subjects.add(word); } } } // Analyser les sous-dossiers for (const child of structure.children) { this.extractSubjectsFromStructure(child, subjects); } } isCommonWord(word) { const commonWords = [ 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'le', 'la', 'les', 'un', 'une', 'des', 'du', 'de', 'et', 'ou', 'mais', 'dans', 'sur', 'sous', 'avec', 'sans', 'pour', 'par', 'vers', 'depuis', 'pendant', 'file', 'folder', 'dir', 'doc', 'txt', 'pdf', 'img', 'pic', 'photo', 'image', 'video', 'audio', 'data', 'info', 'config', 'settings', 'temp', 'tmp', 'backup' ]; return commonWords.includes(word); } async identifySources() { console.log('\nüìö 4. Identification des sources...'); const sources = new Set(); // Analyser les fichiers pour identifier les sources this.extractSourcesFromStructure(this.report.structure, sources); this.report.sources = Array.from(sources); console.log(`üìä Sources identifi√©es: ${this.report.sources.length}`); for (const source of this.report.sources) { console.log(` - ${source}`); } this.report.actions.push(`Identifi√© ${this.report.sources.length} sources`); } extractSourcesFromStructure(structure, sources) { // Analyser les fichiers texte pour identifier les sources for (const file of structure.files) { if (file.type === 'text') { try { const content = fs.readFileSync(file.path, 'utf8'); this.extractSourcesFromContent(content, sources); } catch (error) { // Ignorer les erreurs de lecture } } } // Analyser les sous-dossiers for (const child of structure.children) { this.extractSourcesFromStructure(child, sources); } } extractSourcesFromContent(content, sources) { // Chercher des patterns de sources (URLs, r√©f√©rences, etc.) const urlPattern = /https?:\/\/[^\s]+/g; const emailPattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g; const filePattern = /[a-zA-Z]:\\[^\s]+/g; const urls = content.match(urlPattern) || []; const emails = content.match(emailPattern) || []; const files = content.match(filePattern) || []; urls.forEach(url => sources.add(url)); emails.forEach(email => sources.add(email)); files.forEach(file => sources.add(file)); } async processFiles() { console.log('\nüìÑ 5. Traitement des fichiers...'); let processedCount = 0; await this.processStructureFiles(this.report.structure, processedCount); console.log(`‚úÖ ${processedCount} fichiers trait√©s`); this.report.actions.push(`Trait√© ${processedCount} fichiers`); } async processStructureFiles(structure, processedCount) { for (const file of structure.files) { try { await this.processSingleFile(file); processedCount++; } catch (error) { console.log(`‚ö†Ô∏è Erreur traitement ${file.name}: ${error.message}`); } } for (const child of structure.children) { await this.processStructureFiles(child, processedCount); } } async processSingleFile(file) { // Traitement sp√©cifique selon le type de fichier switch (file.type) { case 'text': await this.processTextFile(file); break; case 'image': await this.processImageFile(file); break; case 'video': await this.processVideoFile(file); break; case 'audio': await this.processAudioFile(file); break; case 'archive': await this.processArchiveFile(file); break; default: await this.processUnknownFile(file); } } async processTextFile(file) { // Traitement des fichiers texte console.log(` üìÑ Traitement texte: ${file.name}`); } async processImageFile(file) { // Traitement des fichiers image console.log(` üñºÔ∏è Traitement image: ${file.name}`); } async processVideoFile(file) { // Traitement des fichiers vid√©o console.log(` üé• Traitement vid√©o: ${file.name}`); } async processAudioFile(file) { // Traitement des fichiers audio console.log(` üéµ Traitement audio: ${file.name}`); } async processArchiveFile(file) { // Traitement des archives console.log(` üì¶ Traitement archive: ${file.name}`); } async processUnknownFile(file) { // Traitement des fichiers inconnus console.log(` ‚ùì Traitement inconnu: ${file.name}`); } async organizeContent() { console.log('\nüìÇ 6. Organisation du contenu...'); // Cr√©er une structure organis√©e bas√©e sur les sujets identifi√©s const organizedPath = path.join(__dirname, '../organized-content'); if (!fs.existsSync(organizedPath)) { fs.mkdirSync(organizedPath, { recursive: true }); } // Cr√©er des dossiers pour chaque sujet for (const subject of this.report.subjects) { const subjectPath = path.join(organizedPath, subject); if (!fs.existsSync(subjectPath)) { fs.mkdirSync(subjectPath, { recursive: true }); } } console.log('‚úÖ Contenu organis√©'); this.report.actions.push('Contenu organis√©'); } async generateDocumentation() { console.log('\nüìö 7. G√©n√©ration de la documentation...'); const docsPath = path.join(__dirname, '../docs'); if (!fs.existsSync(docsPath)) { fs.mkdirSync(docsPath, { recursive: true }); } // G√©n√©rer la documentation de la structure const structureDoc = this.generateStructureDocumentation(); fs.writeFileSync(path.join(docsPath, 'structure.md'), structureDoc); // G√©n√©rer la documentation des sujets const subjectsDoc = this.generateSubjectsDocumentation(); fs.writeFileSync(path.join(docsPath, 'subjects.md'), subjectsDoc); // G√©n√©rer la documentation des sources const sourcesDoc = this.generateSourcesDocumentation(); fs.writeFileSync(path.join(docsPath, 'sources.md'), sourcesDoc); console.log('‚úÖ Documentation g√©n√©r√©e'); this.report.actions.push('Documentation g√©n√©r√©e'); } generateStructureDocumentation() { return `# üìÅ Documentation de la Structure ## üìÖ Date **${new Date().toLocaleString('fr-FR')}** ## üìÇ Dossier Analys√© **${this.targetFolder}** ## üìä Statistiques - **Fichiers**: ${this.report.structure.stats?.totalFiles || 0} - **Dossiers**: ${this.report.structure.stats?.totalDirectories || 0} - **Taille totale**: ${this.formatBytes(this.report.structure.stats?.totalSize || 0)} ## üèóÔ∏è Structure \`\`\` ${this.generateStructureTree(this.report.structure)} \`\`\` --- *G√©n√©r√© automatiquement par ExternalFolderProcessor* `; } generateStructureTree(structure, indent = '') { let tree = `${indent}üìÅ ${structure.name}\n`; for (const file of structure.files) { tree += `${indent} üìÑ ${file.name} (${this.formatBytes(file.size)})\n`; } for (const child of structure.children) { tree += this.generateStructureTree(child, indent + ' '); } return tree; } generateSubjectsDocumentation() { return `# üéØ Documentation des Sujets ## üìÖ Date **${new Date().toLocaleString('fr-FR')}** ## üìä Sujets Identifi√©s **${this.report.subjects.length} sujets trouv√©s** ## üìã Liste des Sujets ${this.report.subjects.map(subject => `- **${subject}**`).join('\n')} ## üîç Analyse Les sujets ont √©t√© extraits automatiquement des noms de fichiers et dossiers. --- *G√©n√©r√© automatiquement par ExternalFolderProcessor* `; } generateSourcesDocumentation() { return `# üìö Documentation des Sources ## üìÖ Date **${new Date().toLocaleString('fr-FR')}** ## üìä Sources Identifi√©es **${this.report.sources.length} sources trouv√©es** ## üìã Liste des Sources ${this.report.sources.map(source => `- **${source}**`).join('\n')} ## üîç Analyse Les sources ont √©t√© extraites automatiquement du contenu des fichiers. --- *G√©n√©r√© automatiquement par ExternalFolderProcessor* `; } formatBytes(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; } async createReports() { console.log('\nüìä 8. Cr√©ation des rapports...'); const reportsPath = path.join(__dirname, '../reports'); if (!fs.existsSync(reportsPath)) { fs.mkdirSync(reportsPath, { recursive: true }); } // Rapport JSON complet const jsonReport = JSON.stringify(this.report, null, 2); fs.writeFileSync(path.join(reportsPath, 'external-folder-analysis.json'), jsonReport); // Rapport Markdown const markdownReport = this.generateMarkdownReport(); fs.writeFileSync(path.join(reportsPath, 'external-folder-analysis.md'), markdownReport); console.log('‚úÖ Rapports cr√©√©s'); this.report.actions.push('Rapports cr√©√©s'); } generateMarkdownReport() { return `# üöÄ RAPPORT D'ANALYSE - DOSSIER EXTERNE ## üìÖ Date **${new Date().toLocaleString('fr-FR')}** ## üìÅ Dossier Analys√© **${this.targetFolder}** ## üìä Statistiques - **Fichiers trait√©s**: ${this.report.filesProcessed} - **Dossiers trait√©s**: ${this.report.foldersProcessed} - **Sujets identifi√©s**: ${this.report.subjects.length} - **Sources identifi√©es**: ${this.report.sources.length} - **Erreurs**: ${this.report.errors.length} - **Avertissements**: ${this.report.warnings.length} ## ‚úÖ Actions Effectu√©es ${this.report.actions.map(action => `- ‚úÖ ${action}`).join('\n')} ## üéØ Sujets Identifi√©s ${this.report.subjects.map(subject => `- **${subject}**`).join('\n')} ## üìö Sources Identifi√©es ${this.report.sources.map(source => `- **${source}**`).join('\n')} ## ‚ùå Erreurs ${this.report.errors.map(error => `- ‚ùå ${error}`).join('\n')} ## ‚ö†Ô∏è Avertissements ${this.report.warnings.map(warning => `- ‚ö†Ô∏è ${warning}`).join('\n')} ## üéØ Objectifs Atteints - ‚úÖ Analyse de la structure - ‚úÖ Identification des sujets - ‚úÖ Identification des sources - ‚úÖ Traitement des fichiers - ‚úÖ Organisation du contenu - ‚úÖ G√©n√©ration de documentation - ‚úÖ Cr√©ation de rapports --- **üìÖ G√©n√©r√©**: ${new Date().toISOString()} **üéØ Objectif**: Analyse compl√®te du dossier externe **‚úÖ Statut**: **TERMIN√â AVEC SUCC√àS** `; } } // Ex√©cution const processor = new ExternalFolderProcessor(); processor.processAll().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});