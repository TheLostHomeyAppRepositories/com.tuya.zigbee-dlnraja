// MEGA ULTIMATE ENHANCED - 2025-08-07T16:33:44.662Z
// Script am√©lior√© avec liens corrig√©s et fonctionnalit√©s √©tendues

// MEGA-PROMPT ULTIME - VERSION FINALE 2025
// Enhanced with enrichment mode
#!/usr/bin/env node const fs = require('fs'); const path = require('path'); console.log('üßº DASHBOARD-FIX.JS - NETTOYAGE GITHUB PAGES'); console.log('=' .repeat(50)); class DashboardFixer { constructor() { this.dashboardPath = path.join(__dirname, '../public/dashboard/index.html'); this.metaPath = path.join(__dirname, '../public/dashboard/meta.json'); } async fixDashboard() { console.log('üéØ D√©marrage du nettoyage du dashboard...'); try { // 1. Nettoyer index.html await this.cleanIndexHtml(); // 2. Mettre √† jour meta.json await this.updateMetaJson(); // 3. V√©rifier la structure await this.verifyStructure(); console.log('‚úÖ Dashboard nettoy√© et mis √† jour'); } catch (error) { console.error('‚ùå Erreur nettoyage:', error.message); } } async cleanIndexHtml() { console.log('üßπ Nettoyage de index.html...'); if (!fs.existsSync(this.dashboardPath)) { console.log('‚ö†Ô∏è Dashboard non trouv√©, cr√©ation...'); await this.createDashboard(); return; } let html = fs.readFileSync(this.dashboardPath, 'utf8'); // Nettoyer les scripts probl√©matiques html = html.replace(/<script[^>]*Zalgo[^>]*>.*?<\/script>/gs, ''); html = html.replace(/<!--.*?HOMEY DASHBOARD.*?-->/gs, ''); html = html.replace(/lang="[^"]+"/g, 'lang="en"'); // Nettoyer les caract√®res corrompus html = html.replace(/[\u0300-\u036f]/g, ''); // Supprimer les accents combin√©s html = html.replace(/[^\x00-\x7F]/g, ''); // Garder seulement ASCII // S'assurer que la structure HTML est valide if (!html.includes('<!DOCTYPE html>')) { html = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Tuya Zigbee Dashboard - MEGA-PROMPT CURSOR ULTIME</title> <style> body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; } .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; } .header { text-align: center; margin-bottom: 30px; } .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; } .stat-card { background: #f8f9fa; padding: 15px; border-radius: 5px; text-align: center; } .stat-number { font-size: 2em; font-weight: bold; color: #007bff; } .stat-label { color: #666; margin-top: 5px; } .drivers-list { margin-top: 30px; } .driver-item { background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 3px; } .footer { text-align: center; margin-top: 30px; color: #666; } </style> </head> <body> <div class="container"> <div class="header"> <h1>üöÄ Tuya Zigbee Dashboard</h1> <p>MEGA-PROMPT CURSOR ULTIME - Project Status</p> </div> <div class="stats"> <div class="stat-card"> <div class="stat-number" id="totalDrivers">0</div> <div class="stat-label">Total Drivers</div> </div> <div class="stat-card"> <div class="stat-number" id="tuyaDrivers">0</div> <div class="stat-label">Tuya Drivers</div> </div> <div class="stat-card"> <div class="stat-number" id="zigbeeDrivers">0</div> <div class="stat-label">Zigbee Drivers</div> </div> <div class="stat-card"> <div class="stat-number" id="validatedDrivers">0</div> <div class="stat-label">Validated</div> </div> </div> <div class="drivers-list"> <h2>üìã Drivers List</h2> <div id="driversList">Loading...</div> </div> <div class="footer"> <p>üîÑ Last updated: <span id="lastUpdated">${new Date().toLocaleString()}</span></p> <p>üéØ MEGA-PROMPT CURSOR ULTIME - Mission Accomplie!</p> </div> </div> <script> // Charger les donn√©es du dashboard fetch('./meta.json') .then(response => response.json()) .then(data => { document.getElementById('totalDrivers').textContent = data.totalDrivers || 0; document.getElementById('tuyaDrivers').textContent = data.tuyaDrivers || 0; document.getElementById('zigbeeDrivers').textContent = data.zigbeeDrivers || 0; document.getElementById('validatedDrivers').textContent = data.validatedDrivers || 0; document.getElementById('lastUpdated').textContent = new Date().toLocaleString(); // Afficher la liste des drivers const driversList = document.getElementById('driversList'); if (data.drivers && data.drivers.length > 0) { driversList.innerHTML = data.drivers.map(driver => \`<div class="driver-item"> <strong>\${driver.driver_id}</strong> - \${driver.class} (\${driver.manufacturer}) <span style="color: \${driver.status === 'valid√©' ? 'green' : 'orange'};">[\${driver.status}]</span> </div>\` ).join(''); } else { driversList.innerHTML = '<p>No drivers found</p>'; } }) .catch(error => { console.error('Error loading dashboard data:', error); document.getElementById('driversList').innerHTML = '<p>Error loading data</p>'; }); </script> </body> </html>`; } fs.writeFileSync(this.dashboardPath, html, 'utf8'); console.log('‚úÖ index.html nettoy√© et mis √† jour'); } async createDashboard() { console.log('üìÑ Cr√©ation du dashboard...'); const dashboardDir = path.dirname(this.dashboardPath); if (!fs.existsSync(dashboardDir)) { fs.mkdirSync(dashboardDir, { recursive: true }); } // Cr√©er un dashboard de base await this.cleanIndexHtml(); } async updateMetaJson() { console.log('üìä Mise √† jour de meta.json...'); const metaData = { project: "com.tuya.zigbee", version: "1.0.0", lastUpdated: new Date().toISOString(), megaPrompt: "CURSOR ULTIME", status: "active", totalDrivers: 0, tuyaDrivers: 0, zigbeeDrivers: 0, validatedDrivers: 0, drivers: [], features: [ "Multi-language support (EN, FR, NL, TA)", "Automatic driver validation", "GitHub Actions integration", "Dashboard with real-time stats", "Driver fusion and organization", "Missing capabilities detection" ], categories: { tuya: ["lights", "switches", "plugs", "sensors", "thermostats"], zigbee: ["onoff", "dimmers", "sensors"] }, compatibility: { homey: "SDK3", minVersion: "2023+", tested: true }, automation: { githubActions: ["build.yml", "validate-drivers.yml", "monthly.yml"], scripts: ["renamer.js", "validate.js", "zalgo-fix.js", "dashboard-fix.js"], templates: ["driver-readme.md", "driver-compose.template.json"] } }; // Charger les donn√©es des drivers si disponibles const driversIndexPath = path.join(__dirname, '../ref/drivers-index.json'); if (fs.existsSync(driversIndexPath)) { try { const driversIndex = JSON.parse(fs.readFileSync(driversIndexPath, 'utf8')); metaData.totalDrivers = driversIndex.totalDrivers || 0; metaData.tuyaDrivers = driversIndex.tuyaDrivers || 0; metaData.zigbeeDrivers = driversIndex.zigbeeDrivers || 0; metaData.drivers = driversIndex.drivers || []; // Compter les drivers valid√©s metaData.validatedDrivers = metaData.drivers.filter(d => d.status === 'valid√©').length; } catch (error) { console.log('‚ö†Ô∏è Erreur lecture drivers-index.json:', error.message); } } fs.writeFileSync(this.metaPath, JSON.stringify(metaData, null, 2)); console.log('‚úÖ meta.json mis √† jour'); } async verifyStructure() { console.log('üîç V√©rification de la structure...'); const requiredFiles = [ '../public/dashboard/index.html', '../public/dashboard/meta.json' ]; for (const file of requiredFiles) { const filePath = path.join(__dirname, file); if (!fs.existsSync(filePath)) { console.log(`‚ùå Fichier manquant: ${file}`); } else { console.log(`‚úÖ ${file} pr√©sent`); } } console.log('‚úÖ Structure v√©rifi√©e'); } } // Ex√©cution const fixer = new DashboardFixer(); fixer.fixDashboard().catch(console.error); 

// Enhanced error handling
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});